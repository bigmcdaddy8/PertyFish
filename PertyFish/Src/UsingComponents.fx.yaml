UsingComponents As screen:

    comUtilityFunctionsLibrary As comUtilityFunctions:
        fUtilInitData: |+
            =Switch(true,
                pInitType=-1,
                    Blank(),
            
                pInitType=1,
                    Set(gblPF_UI_whiteCapturedPieces, "");
                    Set(gblPF_UI_blackCapturedPieces, "");
                    ClearCollect(colPF_MOVE_HISTORY, Table(NODE_RECORD_PF));
                    ClearCollect(colPF_MOVE_TREE, Table(NODE_RECORD_PF));
                    RemoveIf(colPF_MOVE_HISTORY, nodeID<0);
                    RemoveIf(colPF_MOVE_TREE, nodeID<0);
                    Clear(colPF_Timers);
                    Reset(galChessBoard),
            
                pInitType=100,
                    ClearCollect(colPF_logs, Table({logOffset: 0, logEntry: ""})),
            
                // default
                Set(gblPF_TMR_RunNextTest, false);
                Set(gblPF_TMR_MakeNextTestMove, false);
                Set(gblPF_TMR_MakeNextGameMove, false);
                Set(gblPF_PAUSE, false);
                Set(gblPF_UI_selectedSqNum, EMPTY_SQUARE_NUM);
                Set(gblPF_UI_Ready4Input, false);
                Set(gblPF_UI_DisplayedBoard, EMPTY_BOARD);
                Set(gblPF_UI_DisplayedFEN, "");
                Set(gblPF_UI_GameTurn, WHITE);
                Set(gblPF_UI_whiteCapturedPieces, "");
                Set(gblPF_UI_blackCapturedPieces, "");
                Set(gblPF_UI_MaterialValueOverall, 0);
                Set(gblPF_UI_ThinkingText, "");
                Set(gblPF_UI_StatusText, "Restarting...");
                Set(gblPF_UI_DiagnosticText, "");
                Set(gblPF_UI_ModeFill, COLOR_WHITEish);
                Set(gblPF_UI_ThinkingFill, COLOR_WHITEish);
                Set(gblPF_UI_StatusFill, COLOR_WHITEish);
                Set(gblPF_UI_DiagnosticFill, COLOR_WHITEish);
            
                ClearCollect(colPF_logs, Table({logOffset: 0, logEntry: ""}));
                ClearCollect(colPF_DYNAMIC_DATA, Table(PF_DYNAMIC_DATA));
                Clear(colPF_Timers);
            
                UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                    uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                UI_ready4Input:     gblPF_UI_Ready4Input,
                                UI_sourceSqNum:     gblPF_UI_selectedSqNum,
                                statusText:         gblPF_UI_StatusText,
                                statusFill:         gblPF_UI_StatusFill,
                                diagnosticText:     gblPF_UI_DiagnosticText,
                                diagnosticFill:     gblPF_UI_DiagnosticFill
                            })
                });
            
                Reset(galChessBoard);
            );
            
            

    comChessEngineFunctionsLibrary As comChessEngineFunctions:
        fME_EvaluateMove: |
            =
            If(gblPF_DEBUG_EVAL,
                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                    " comChessEngineFunctions.fME_EvaluateMove(): entered pNodeID: " & pNodeID
                })
            );
            
            With(
                LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
            
                With(
                    LookUp(colPF_MOVE_TREE, nodeID=pNodeID) As theCurrentNode,
            
                    If(gblPF_DEBUG_EVAL,
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " fME_EvaluateMove(): san: " & theCurrentNode.inactiveColorMoveRecord.san &
                            " pacn: " & theCurrentNode.inactiveColorMoveRecord.pacn &
                            " move color: " & UDF_FEN_TO_ACTIVE_COLOR(theCurrentNode.preMoveFEN) &
                            " captureSquareOccupier: " & theCurrentNode.inactiveColorMoveRecord.captureSquareOccupier
                        })
                    );
            
                    // https://www.quora.com/What-are-some-heuristics-for-quickly-evaluating-chess-positions
                    //UpdateIf(colPF_MOVE_TREE, nodeID=pNodeID, {
                    Patch(colPF_MOVE_TREE, First(Filter(colPF_MOVE_TREE, nodeID=pNodeID)), {
                        postMoveEvalRecord: 
                            Patch(EVAL_RECORD_PF, {
                                heuristic01:
                                    0,
                                heuristic02:
                                    0,
                                heuristic05:
                                    0,
                                heuristic11:
                                    0,
                                heuristic12:
                                    0,
                                heuristic13:
                                    0,
                                heuristic14:    
                                    0,
                                heuristic16:
                                    0,
                                heuristic17:
                                    0,
                                heuristic18:
                                    0,
                                // a pinch of randomness
                                heuristic19:
                                    RandBetween(-5,5)  // centipawns 
                            })
                    });
            
                    UpdateIf(colPF_MOVE_TREE, nodeID=pNodeID, {
                        postMoveEvalRecord: 
                            Patch(LookUp(colPF_MOVE_TREE, nodeID=pNodeID).postMoveEvalRecord, {
                                centipawn:
                                    With(
                                        LookUp(colPF_MOVE_TREE, nodeID=pNodeID) As theCurrentNodeUpdated,
                                        
                                        If(gblPF_DEBUG_EVAL,
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic01 (basic positioning) SUM BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic01
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic02 ME end game: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic02
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic05 (Hanging Piece Tactic) SUM BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic05
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic11 generic tactics BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic11
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic12 fork tactic BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic12
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic13 move to/from protection BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic13
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic14 castling BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic14
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic16 BNP moves in opening sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic16
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic17 passed PAWN BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic17
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic18 Post Square Table (PST) BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic18
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic19 the God of Randomness BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic19
                                            })
                                        );
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic01 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic02 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic03 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic04 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic05 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic06 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic07 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic08 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic09 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic10 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic11 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic12 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic13 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic14 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic15 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic16 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic17 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic18 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic19
                                    )
                            })
                    })
                );
            
                If(gblPF_DEBUG_EVAL,
                    With(
                        LookUp(colPF_MOVE_TREE, nodeID=pNodeID) As theCurrentNode,
            
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " fME_EvaluateMove(): san: " & theCurrentNode.inactiveColorMoveRecord.san &
                            " pacn: " & theCurrentNode.inactiveColorMoveRecord.pacn &
                            " centipawn: " & theCurrentNode.postMoveEvalRecord.centipawn
                        })
                    )
                )
            );
            
            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & " fME_EvaluateMove(): exiting"});
        fME_EvaluateMove_BEGINNER: =
        ZIndex: =2

