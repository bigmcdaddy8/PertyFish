UsingComponents As screen:

    comUtilityFunctionsLibrary As comUtilityFunctions:
        fUtilInitData: |+
            =Switch(true,
                pInitType=-1,
                    Blank(),
            
                pInitType=1,
                    Set(gblPF_UI_whiteCapturedPieces, "");
                    Set(gblPF_UI_blackCapturedPieces, "");
                    ClearCollect(colPF_MOVE_HISTORY, Table(NODE_RECORD_PF));
                    ClearCollect(colPF_MOVE_TREE, Table(NODE_RECORD_PF));
                    RemoveIf(colPF_MOVE_HISTORY, nodeID<0);
                    RemoveIf(colPF_MOVE_TREE, nodeID<0);
                    Clear(colPF_Timers);
                    Reset(galChessBoard),
            
                pInitType=100,
                    ClearCollect(colPF_logs, Table({logOffset: 0, logEntry: ""})),
            
                // default
                Set(gblPF_TMR_RunNextTest, false);
                Set(gblPF_TMR_MakeNextTestMove, false);
                Set(gblPF_TMR_MakeNextGameMove, false);
                Set(gblPF_PAUSE, false);
                Set(gblPF_UI_selectedSqNum, EMPTY_SQUARE_NUM);
                Set(gblPF_UI_Ready4Input, false);
                Set(gblPF_UI_DisplayedBoard, EMPTY_BOARD);
                Set(gblPF_UI_DisplayedFEN, "");
                Set(gblPF_UI_GameTurn, WHITE);
                Set(gblPF_UI_whiteCapturedPieces, "");
                Set(gblPF_UI_blackCapturedPieces, "");
                Set(gblPF_UI_MaterialValueOverall, 0);
                Set(gblPF_UI_ThinkingText, "");
                Set(gblPF_UI_StatusText, "Restarting...");
                Set(gblPF_UI_DiagnosticText, "");
                Set(gblPF_UI_ModeFill, COLOR_WHITEish);
                Set(gblPF_UI_ThinkingFill, COLOR_WHITEish);
                Set(gblPF_UI_StatusFill, COLOR_WHITEish);
                Set(gblPF_UI_DiagnosticFill, COLOR_WHITEish);
            
                ClearCollect(colPF_logs, Table({logOffset: 0, logEntry: ""}));
                ClearCollect(colPF_DYNAMIC_DATA, Table(PF_DYNAMIC_DATA));
                Clear(colPF_Timers);
            
                UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                    uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                UI_ready4Input:     gblPF_UI_Ready4Input,
                                UI_sourceSqNum:     gblPF_UI_selectedSqNum,
                                statusText:         gblPF_UI_StatusText,
                                statusFill:         gblPF_UI_StatusFill,
                                diagnosticText:     gblPF_UI_DiagnosticText,
                                diagnosticFill:     gblPF_UI_DiagnosticFill
                            })
                });
            
                Reset(galChessBoard);
            );
            
            

    comChessEngineFunctionsLibrary As comChessEngineFunctions:
        fCE_100: |
            =
            If(gblPF_DEBUG_EVAL,
                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                    " comChessEngineFunctions.fCE_100(): entered pNodeID: " & pNodeID
                })
            );
            
            With(
                LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
            
                With(
                    LookUp(colPF_MOVE_TREE, nodeID=pNodeID) As theCurrentNode,
            
                    If(gblPF_DEBUG_EVAL,
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " fCE_100(): san: " & theCurrentNode.inactiveColorMoveRecord.san &
                            " pacn: " & theCurrentNode.inactiveColorMoveRecord.pacn &
                            " move color: " & UDF_FEN_TO_ACTIVE_COLOR(theCurrentNode.preMoveFEN) &
                            " captureSquareOccupier: " & theCurrentNode.inactiveColorMoveRecord.captureSquareOccupier
                        })
                    );
            
                    Patch(colPF_MOVE_TREE, First(Filter(colPF_MOVE_TREE, nodeID=pNodeID)), {
                        postMoveEvalRecord: 
                            Patch(EVAL_RECORD_PF, {
                                // a pinch of randomness
                                heuristic19:
                                    RandBetween(-25,25)  // centipawns 
                            })
                    });
            
                    UpdateIf(colPF_MOVE_TREE, nodeID=pNodeID, {
                        postMoveEvalRecord: 
                            Patch(LookUp(colPF_MOVE_TREE, nodeID=pNodeID).postMoveEvalRecord, {
                                centipawn:
                                    With(
                                        LookUp(colPF_MOVE_TREE, nodeID=pNodeID) As theCurrentNodeUpdated,
                                        
                                        If(gblPF_DEBUG_EVAL,
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic19 the God of Randomness BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic19
                                            })
                                        );
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic01 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic02 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic03 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic04 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic05 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic06 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic07 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic08 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic09 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic10 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic11 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic12 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic13 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic14 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic15 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic16 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic17 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic18 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic19
                                    )
                            })
                    })
                );
            
                If(gblPF_DEBUG_EVAL,
                    With(
                        LookUp(colPF_MOVE_TREE, nodeID=pNodeID) As theCurrentNode,
            
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " fCE_100(): san: " & theCurrentNode.inactiveColorMoveRecord.san &
                            " pacn: " & theCurrentNode.inactiveColorMoveRecord.pacn &
                            " centipawn: " & theCurrentNode.postMoveEvalRecord.centipawn
                        })
                    )
                )
            );
            
            If(gblPF_DEBUG_EVAL,
                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & " fCE_100(): exiting"})
            )
        fCE_200: |+
            =
            If(gblPF_DEBUG_EVAL,
                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                    " comChessEngineFunctions.fCE_200(): entered pNodeID: " & pNodeID
                })
            );
            
            With(
                LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
            
                With(
                    LookUp(colPF_MOVE_TREE, nodeID=pNodeID) As theCurrentNode,
            
                    If(gblPF_DEBUG_EVAL,
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " fCE_200(): san: " & theCurrentNode.inactiveColorMoveRecord.san &
                            " pacn: " & theCurrentNode.inactiveColorMoveRecord.pacn &
                            " move color: " & UDF_FEN_TO_ACTIVE_COLOR(theCurrentNode.preMoveFEN) &
                            " captureSquareOccupier: " & theCurrentNode.inactiveColorMoveRecord.captureSquareOccupier
                        })
                    );
            
                    Patch(colPF_MOVE_TREE, First(Filter(colPF_MOVE_TREE, nodeID=pNodeID)), {
                        postMoveEvalRecord: 
                            Patch(EVAL_RECORD_PF, {
                                heuristic11:
                                    Sum(
                                        ForAll(
                                            Split(UDF_FEN_TO_PIECE_PLACEMENT(theCurrentNode.postMoveFEN), "") As thePiece,
            
                                            UDF_getPieceCentipawnMaterialValue(thePiece.Value, "QRBNPqrbnp")
                                        ),
                                        Value
                                    ) -
                                    Sum(
                                        ForAll(
                                            Split(UDF_FEN_TO_PIECE_PLACEMENT(theCurrentNode.preMoveFEN), "") As thePiece,
            
                                            UDF_getPieceCentipawnMaterialValue(thePiece.Value, "QRBNPqrbnp")
                                        ),
                                        Value
                                    ),
                                heuristic19:
                                    If(UDF_FEN_TO_ACTIVE_COLOR(theCurrentNode.preMoveFEN)=WHITE,
                                        If(theCurrentNode.inactiveColorMoveRecord.captureSquareNum<>EMPTY_SQUARE_NUM, RandBetween(0,25), RandBetween(-25,0)),
                                        If(theCurrentNode.inactiveColorMoveRecord.captureSquareNum<>EMPTY_SQUARE_NUM, RandBetween(-25,0), RandBetween(0,25))
                                    )
                            })
                    });
            
                    UpdateIf(colPF_MOVE_TREE, nodeID=pNodeID, {
                        postMoveEvalRecord: 
                            Patch(LookUp(colPF_MOVE_TREE, nodeID=pNodeID).postMoveEvalRecord, {
                                centipawn:
                                    With(
                                        LookUp(colPF_MOVE_TREE, nodeID=pNodeID) As theCurrentNodeUpdated,
                                        
                                        If(gblPF_DEBUG_EVAL,
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic11 Basic Material BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic11
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic19 the God of Randomness BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic19
                                            })
                                        );
                                        Sum(
                                            theCurrentNodeUpdated.postMoveEvalRecord.heuristic11,
                                            theCurrentNodeUpdated.postMoveEvalRecord.heuristic19
                                        )
                                    )
                            })
                    })
                );
            
                If(gblPF_DEBUG_EVAL,
                    With(
                        LookUp(colPF_MOVE_TREE, nodeID=pNodeID) As theCurrentNode,
            
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " fCE_200(): san: " & theCurrentNode.inactiveColorMoveRecord.san &
                            " pacn: " & theCurrentNode.inactiveColorMoveRecord.pacn &
                            " centipawn: " & theCurrentNode.postMoveEvalRecord.centipawn
                        })
                    )
                )
            );
            
            If(gblPF_DEBUG_EVAL,
                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & " fCE_200(): exiting"})
            )
            
        fCE_300: |+
            =
            If(gblPF_DEBUG_EVAL,
                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                    " comChessEngineFunctions.fCE_300(): entered pNodeID: " & pNodeID
                })
            );
            
            If(gblPF_DEBUG_TIMERS,
                If(IsBlank(LookUp(colPF_Timers, timerName="comChessEngineFunctions.fCE_300")),
                    Collect(colPF_Timers, {timerName:"comChessEngineFunctions.fCE_300",startTime:Now(),stopTime:Blank()}),
                    UpdateIf(colPF_Timers, timerName="comChessEngineFunctions.fCE_300", { startTime: Now() })
                )
            );
            
            With(
                {
                    theCurrentNode:    LookUp(colPF_MOVE_TREE, nodeID=pNodeID),
                    theParentNode:     LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_MOVE_TREE, nodeID=pNodeID).parentNodeID)
                } As theNodes,
            
                If(gblPF_DEBUG_TIMERS,
                    If(IsBlank(LookUp(colPF_Timers, timerName="comChessEngineFunctions.fCE_300.PREP")),
                        Collect(colPF_Timers, {timerName:"comChessEngineFunctions.fCE_300.PREP",startTime:Now(),stopTime:Blank()}),
                        UpdateIf(colPF_Timers, timerName="comChessEngineFunctions.fCE_300.PREP", { startTime: Now() })
                    )
                );
            
                If(gblPF_DEBUG_EVAL,
                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                        " fCE_300(): DEBUG board pre-update dump"
                    });
                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                        " ParentNode whiteStrongSqBoard: " & theNodes.theParentNode.postMoveEvalRecord.whiteStrongSqBoard
                    });
                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                        " ParentNode blackStrongSqBoard: " & theNodes.theParentNode.postMoveEvalRecord.blackStrongSqBoard 
                    });
                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                        " CurrentNode whiteStrongSqBoard: " & theNodes.theCurrentNode.postMoveEvalRecord.whiteStrongSqBoard
                    });
                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                        " CurrentNode blackStrongSqBoard: " & theNodes.theCurrentNode.postMoveEvalRecord.blackStrongSqBoard 
                    })
                );
            
                comChessEngineFunctions.fME_prepNode(100, theNodes.theParentNode.nodeID);
                comChessEngineFunctions.fME_prepNode(100, theNodes.theCurrentNode.nodeID);
                
                If(gblPF_DEBUG_TIMERS,
                    UpdateIf(colPF_Timers, timerName="comChessEngineFunctions.fCE_300.PREP", { stopTime: Now() });
                    With(
                        LookUp(colPF_Timers, timerName="comChessEngineFunctions.fCE_300.PREP") As theTimer,
            
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " comChessEngineFunctions.fCE_300(): PREP total elapsed time: " &
                            Text(DateDiff(theTimer.startTime, theTimer.stopTime, TimeUnit.Milliseconds)/1000) & " seconds"
                        })
                    )
                )
            );
            
            With(
                {
                    theData:        LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME),
                    theCurrentNode: LookUp(colPF_MOVE_TREE, nodeID=pNodeID),
                    theParentNode:  LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_MOVE_TREE, nodeID=pNodeID).parentNodeID),
                    evalRecord:     EVAL_RECORD_PF
                } As localVars,
            
            
                If(gblPF_DEBUG_EVAL,
                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                        " fCE_300(): san: " & localVars.theCurrentNode.inactiveColorMoveRecord.san &
                        " pacn: " & localVars.theCurrentNode.inactiveColorMoveRecord.pacn &
                        " move color: " & UDF_FEN_TO_ACTIVE_COLOR(localVars.theCurrentNode.preMoveFEN) &
                        " captureSquareOccupier: " & localVars.theCurrentNode.inactiveColorMoveRecord.captureSquareOccupier
                    })
                );
            
                If(gblPF_DEBUG_EVAL,
                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                        " post-update parent whiteStrongSqBoard: " & localVars.theParentNode.postMoveEvalRecord.whiteStrongSqBoard
                    })
                );
                If(gblPF_DEBUG_EVAL,
                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                        " post-update parent blackStrongSqBoard: " & localVars.theParentNode.postMoveEvalRecord.blackStrongSqBoard
                    })
                );
                If(gblPF_DEBUG_EVAL,
                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                        " post-update current whiteStrongSqBoard: " & localVars.theCurrentNode.postMoveEvalRecord.whiteStrongSqBoard
                    })
                );
                If(gblPF_DEBUG_EVAL,
                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                        " post-update current blackStrongSqBoard: " & localVars.theCurrentNode.postMoveEvalRecord.blackStrongSqBoard
                    })
                );
            
                With(
                    Patch(localVars, {
                        evalRecord:
                            Patch(localVars.evalRecord, {
                                heuristic19:    If(UDF_FEN_TO_ACTIVE_COLOR(localVars.theCurrentNode.preMoveFEN)=WHITE,
                                                    If(localVars.theCurrentNode.inactiveColorMoveRecord.captureSquareNum<>EMPTY_SQUARE_NUM, RandBetween(0,25), RandBetween(-25,0)),
                                                    If(localVars.theCurrentNode.inactiveColorMoveRecord.captureSquareNum<>EMPTY_SQUARE_NUM, RandBetween(-25,0), RandBetween(0,25))
                                                )
                            })
                    }) As updatedLocalVars,
            
                    If(gblPF_DEBUG_EVAL,
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                            " heuristic11 Basic Material BONUS/PENALTY sub-total: " & updatedLocalVars.evalRecord.heuristic11
                        });
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                            " heuristic15 END_GAME BONUS/PENALTY sub-total: " & updatedLocalVars.evalRecord.heuristic15
                        });
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                            " heuristic19 the God of Randomness BONUS/PENALTY sub-total: " & updatedLocalVars.evalRecord.heuristic19
                        })
                    );
                    UpdateIf(colPF_MOVE_TREE, nodeID=pNodeID, {
                        postMoveEvalRecord: 
                            Patch(updatedLocalVars.evalRecord, {
                                centipawn:  Sum(
                                                updatedLocalVars.evalRecord.heuristic11,
                                                updatedLocalVars.evalRecord.heuristic15,
                                                updatedLocalVars.evalRecord.heuristic19
                                            )
                            })
                    })
                )
            
            
            /*
                    Patch(colPF_MOVE_TREE, First(Filter(colPF_MOVE_TREE, nodeID=pNodeID)), {
                        postMoveEvalRecord: 
                            Patch(EVAL_RECORD_PF, {
                                heuristic11:
                                    Sum(
                                        ForAll(
                                            Split(UDF_FEN_TO_PIECE_PLACEMENT(theCurrentNode.postMoveFEN), "") As thePiece,
            
                                            UDF_getPieceCentipawnMaterialValue(thePiece.Value, "QRBNPqrbnp")
                                        ),
                                        Value
                                    ) -
                                    Sum(
                                        ForAll(
                                            Split(UDF_FEN_TO_PIECE_PLACEMENT(theCurrentNode.preMoveFEN), "") As thePiece,
            
                                            UDF_getPieceCentipawnMaterialValue(thePiece.Value, "QRBNPqrbnp")
                                        ),
                                        Value
                                    ),
                                heuristic15:
                                    With (
                                        {
                                            centipawnAdj: If(comChessEngineFunctions.fME_getGamePhase(pNodeID)=GAME_PHASE_END,comChessEngineFunctions.fME_END_GAME(100,pNodeID),0)
                                        } As localVars,
            
                                        If(UDF_FEN_TO_ACTIVE_COLOR(theCurrentNode.preMoveFEN)=WHITE,localVars.centipawnAdj,0 - localVars.centipawnAdj)
                                    ),
                                heuristic19:
                                    If(UDF_FEN_TO_ACTIVE_COLOR(theCurrentNode.preMoveFEN)=WHITE,
                                        If(theCurrentNode.inactiveColorMoveRecord.captureSquareNum<>EMPTY_SQUARE_NUM, RandBetween(0,25), RandBetween(-25,0)),
                                        If(theCurrentNode.inactiveColorMoveRecord.captureSquareNum<>EMPTY_SQUARE_NUM, RandBetween(-25,0), RandBetween(0,25))
                                    )
                            })
                    });
             */
            );
            
            If(gblPF_DEBUG_EVAL,
                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & " fCE_300(): exiting"})
            );
            
            If(gblPF_DEBUG_TIMERS,
                UpdateIf(colPF_Timers, timerName="comChessEngineFunctions.fCE_300", { stopTime: Now() });
                With(
                    LookUp(colPF_Timers, timerName="comChessEngineFunctions.fCE_300") As theTimer,
            
                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                        " comChessEngineFunctions.fCE_300(): total elapsed time: " &
                        Text(DateDiff(theTimer.startTime, theTimer.stopTime, TimeUnit.Milliseconds)/1000) & " seconds"
                    })
                )
            );
            
        fCE_400: |+
            =
            If(gblPF_DEBUG_EVAL,
                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                    " comChessEngineFunctions.fCE_400(): entered pNodeID: " & pNodeID
                })
            );
            
            With(
                LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
            
                With(
                    LookUp(colPF_MOVE_TREE, nodeID=pNodeID) As theCurrentNode,
            
                    If(gblPF_DEBUG_EVAL,
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " fCE_400(): san: " & theCurrentNode.inactiveColorMoveRecord.san &
                            " pacn: " & theCurrentNode.inactiveColorMoveRecord.pacn &
                            " move color: " & UDF_FEN_TO_ACTIVE_COLOR(theCurrentNode.preMoveFEN) &
                            " captureSquareOccupier: " & theCurrentNode.inactiveColorMoveRecord.captureSquareOccupier
                        })
                    );
            
                    Patch(colPF_MOVE_TREE, First(Filter(colPF_MOVE_TREE, nodeID=pNodeID)), {
                        postMoveEvalRecord: 
                            Patch(EVAL_RECORD_PF, {
                                heuristic01:
                                    0,
                                heuristic02:
                                    0,
                                heuristic05:
                                    0,
                                heuristic11:
                                    0,
                                heuristic12:
                                    0,
                                heuristic13:
                                    0,
                                heuristic14:    
                                    0,
                                heuristic16:
                                    0,
                                heuristic17:
                                    0,
                                heuristic18:
                                    0,
                                // a pinch of randomness
                                heuristic19:
                                    If(UDF_FEN_TO_ACTIVE_COLOR(theCurrentNode.preMoveFEN)=WHITE,
                                        // THEN
                                        Switch(comChessEngineFunctions.fME_getGamePhase(theCurrentNode.preMoveFEN),
                                            GAME_PHASE_OPENING,
                                                If(theCurrentNode.inactiveColorMoveRecord.sourceSquareOccupier in "NP", RandBetween(0,25), RandBetween(-25,0)),
                                            GAME_PHASE_MIDDLE,
                                                If(theCurrentNode.inactiveColorMoveRecord.sourceSquareOccupier in "QBNP", RandBetween(0,25), RandBetween(-25,0)),
                                            RandBetween(-25,25)
                                        ),
            
                                        // ELSE
                                        Switch(comChessEngineFunctions.fME_getGamePhase(theCurrentNode.preMoveFEN),
                                            GAME_PHASE_OPENING,
                                                If(theCurrentNode.inactiveColorMoveRecord.sourceSquareOccupier in "NP", RandBetween(-25,0), RandBetween(0,25)),
                                            GAME_PHASE_MIDDLE,
                                                If(theCurrentNode.inactiveColorMoveRecord.sourceSquareOccupier in "QBNP", RandBetween(-25,0), RandBetween(0,25)),
                                            RandBetween(-25,25)
                                        )
                                    )
                            })
                    });
            
                    UpdateIf(colPF_MOVE_TREE, nodeID=pNodeID, {
                        postMoveEvalRecord: 
                            Patch(LookUp(colPF_MOVE_TREE, nodeID=pNodeID).postMoveEvalRecord, {
                                centipawn:
                                    With(
                                        LookUp(colPF_MOVE_TREE, nodeID=pNodeID) As theCurrentNodeUpdated,
                                        
                                        If(gblPF_DEBUG_EVAL,
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic01 (basic positioning) SUM BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic01
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic02 ME end game: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic02
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic05 (Hanging Piece Tactic) SUM BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic05
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic11 generic tactics BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic11
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic12 fork tactic BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic12
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic13 move to/from protection BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic13
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic14 castling BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic14
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic16 BNP moves in opening sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic16
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic17 passed PAWN BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic17
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic18 Post Square Table (PST) BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic18
                                            });
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " heuristic19 the God of Randomness BONUS/PENALTY sub-total: " & theCurrentNodeUpdated.postMoveEvalRecord.heuristic19
                                            })
                                        );
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic01 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic02 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic03 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic04 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic05 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic06 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic07 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic08 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic09 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic10 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic11 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic12 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic13 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic14 +
                                        // theCurrentNodeUpdated.postMoveEvalRecord.heuristic15 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic16 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic17 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic18 +
                                        theCurrentNodeUpdated.postMoveEvalRecord.heuristic19
                                    )
                            })
                    })
                );
            
                If(gblPF_DEBUG_EVAL,
                    With(
                        LookUp(colPF_MOVE_TREE, nodeID=pNodeID) As theCurrentNode,
            
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " fCE_400(): san: " & theCurrentNode.inactiveColorMoveRecord.san &
                            " pacn: " & theCurrentNode.inactiveColorMoveRecord.pacn &
                            " centipawn: " & theCurrentNode.postMoveEvalRecord.centipawn
                        })
                    )
                )
            );
            
            If(gblPF_DEBUG_EVAL,
                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & " fCE_400(): exiting"})
            )
            
        fME_END_GAME: |
            =If(gblPF_DEBUG_EVAL,
                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                    " comChessEngineFunctions.fME_END_GAME(): entered pVersion: " & pVersion &
                    " pNodeID: " & pNodeID
                })
            );
            
            With(
                LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
            
                With(
                    LookUp(colPF_MOVE_TREE, nodeID=pNodeID) As theCurrentNode,
            
                    If(gblPF_DEBUG_EVAL,
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " fME_END_GAME(): san: " & theCurrentNode.inactiveColorMoveRecord.san &
                            " pacn: " & theCurrentNode.inactiveColorMoveRecord.pacn &
                            " move color: " & UDF_FEN_TO_ACTIVE_COLOR(theCurrentNode.preMoveFEN) &
                            " captureSquareOccupier: " & theCurrentNode.inactiveColorMoveRecord.captureSquareOccupier
                        })
                    );
            
                    Sum(0,
                        With (
                            {
                                ppd:    UDF_FEN_TO_PIECE_PLACEMENT(theCurrentNode.postMoveFEN),
                                filterScreen: If(UDF_FEN_TO_INACTIVE_COLOR(theCurrentNode.postMoveFEN)=WHITE,"QRBNP","qrbnp")
                            } As localVars,
            
                            With(
                                {
                                    totalOpponentMaterial: Sum(
                                                            ForAll(
                                                                Split(localVars.ppd, "") As thePiece,
            
                                                                UDF_getPieceCentipawnMaterialValue(thePiece.Value, localVars.filterScreen)
                                                            ),
                                                            Value
                                                        )
                                } As localVars,
            
                                If(localVars.totalOpponentMaterial<>0,
                                    // THEN
                                    0,
            
                                    // ELSE - we are playing against king only
                                    Sum(0,
                                        If(theCurrentNode.inactiveColorMoveRecord.sourceSquareOccupier in "P", 25, 0)
                                    )
                                )
                            )
                        )
                    )
                )
            );
            
            // no exit logging or will mess up return code
        fME_EvaluateMove: |
            =
            If(gblPF_DEBUG_EVAL,
                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                    " comChessEngineFunctions.fME_EvaluateMove(): entered pNodeID: " & pNodeID
                })
            );
            
            With(
                LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
            
                With(
                    LookUp(colPF_MOVE_TREE, nodeID=pNodeID) As theCurrentNode,
            
                    If(gblPF_DEBUG_EVAL,
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " fME_EvaluateMove(): san: " & theCurrentNode.inactiveColorMoveRecord.san &
                            " pacn: " & theCurrentNode.inactiveColorMoveRecord.pacn &
                            " move color: " & UDF_FEN_TO_ACTIVE_COLOR(theCurrentNode.preMoveFEN) &
                            " captureSquareOccupier: " & theCurrentNode.inactiveColorMoveRecord.captureSquareOccupier
                        })
                    );
            
                    // determine which player's turn it is, and then see what their computer setting is currently set to
                    With(
                        {
                            selectedEngine: If(UDF_FEN_TO_ACTIVE_COLOR(theCurrentNode.preMoveFEN)=WHITE, drpWhitePiecesCE.Selected.Value, drpBlackPiecesCE.Selected.Value)
                        } As theEngine,
            
                        If(gblPF_DEBUG_TIMERS,
                            If(IsBlank(LookUp(colPF_Timers, timerName="comChessEngineFunctions.fME_EvaluateMove")),
                                Collect(colPF_Timers, {timerName:"comChessEngineFunctions.fME_EvaluateMove", startTime: Now(), stopTime: Blank() }),
                                UpdateIf(colPF_Timers, timerName="comChessEngineFunctions.fME_EvaluateMove", { startTime: Now(), stopTime: Blank() })
                            )
                        );
                        
                        Switch(true,
                            theEngine.selectedEngine=CE_PF_200,
                                comChessEngineFunctions.fCE_200(pNodeID),
                            theEngine.selectedEngine=CE_PF_300,
                                comChessEngineFunctions.fCE_300(pNodeID),
                            theEngine.selectedEngine=CE_PF_400,
                                comChessEngineFunctions.fCE_400(pNodeID),
                            
                            // default
                            comChessEngineFunctions.fCE_100(pNodeID)
                        );
            
                        If(gblPF_DEBUG_TIMERS,
                            UpdateIf(colPF_Timers, timerName="comChessEngineFunctions.fME_EvaluateMove", { stopTime: Now() });
                            With(
                                LookUp(colPF_Timers, timerName="comChessEngineFunctions.fME_EvaluateMove") As theTimer,
            
                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                    " comChessEngineFunctions.fME_EvaluateMove(): elapsed time " &
                                    Text(DateDiff(theTimer.startTime, theTimer.stopTime, TimeUnit.Milliseconds)/1000) & " seconds" &
                                    " selectedEngine: " & theEngine.selectedEngine
                                    
                                })
                            )
                        )
                    )
                )
            );
            
            
            
            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & " fME_EvaluateMove(): exiting"});
        fME_getGamePhase: |
            =If(gblPF_DEBUG_EVAL,
                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                    " comChessEngineFunctions.fME_getGamePhase(): entered pFEN: " & pFEN
                })
            );
            
            With (
                {
                    board:  UDF_FEN_TO_BOARD(pFEN),
                    ppd:    UDF_FEN_TO_PIECE_PLACEMENT(pFEN)
                } As theBoard,
            
                With (
                    {
                        whiteTotalDevelopment: Sum(
                                                If(UDF_getBitAtSqNum(theBoard.board,51)="P",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,52)="P",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,56)="R",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,57)="N",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,58)="B",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,59)="Q",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,60)="K",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,61)="B",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,62)="N",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,63)="R",0,1)
                                            ),
                        blackTotalDevelopment: Sum(
                                                If(UDF_getBitAtSqNum(theBoard.board,11)="p",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,12)="p",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,0)="r",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,1)="n",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,2)="b",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,3)="q",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,4)="k",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,5)="b",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,6)="n",0,1),
                                                If(UDF_getBitAtSqNum(theBoard.board,7)="r",0,1)
                                            ),
                        whiteTotalMaterial: Sum(
                                                ForAll(
                                                    Split(theBoard.ppd, "") As thePiece,
            
                                                    UDF_getPieceCentipawnMaterialValue(thePiece.Value, "QRBNP")
                                                ),
                                                Value
                                            ),
                        blackTotalMaterial: Abs(
                                                Sum(
                                                    ForAll(
                                                        Split(theBoard.ppd, "") As thePiece,
            
                                                        UDF_getPieceCentipawnMaterialValue(thePiece.Value, "qrbnp")
                                                    ),
                                                    Value
                                                )
                                            )
                    } As theMaterial,
            
                    If(UDF_FEN_TO_ACTIVE_COLOR(pFEN)=WHITE,
                        // THEN
                        Switch(true,
                            Min(theMaterial.whiteTotalMaterial, theMaterial.blackTotalMaterial)>=3000 && 
                            theMaterial.whiteTotalDevelopment<5 &&
                            UDF_FEN_TO_FULLMOVE_COUNT(pFEN)<=10,
                                GAME_PHASE_OPENING,
                            Min(theMaterial.whiteTotalMaterial, theMaterial.blackTotalMaterial)>=1700,
                                GAME_PHASE_MIDDLE,
            
                            // default
                            GAME_PHASE_END
                        ),
            
                        // ELSE
                        Switch(true,
                            Min(theMaterial.whiteTotalMaterial, theMaterial.blackTotalMaterial)>=3000 && 
                            theMaterial.blackTotalDevelopment<5 &&
                            UDF_FEN_TO_FULLMOVE_COUNT(pFEN)<=10,
                                GAME_PHASE_OPENING,
                            Min(theMaterial.whiteTotalMaterial, theMaterial.blackTotalMaterial)>=1700,
                                GAME_PHASE_MIDDLE,
            
                            // default
                            GAME_PHASE_END
                        )
                    )
                )
            );
        fME_prepNode: |+
            =If(gblPF_DEBUG_EVAL,
                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                    " comChessEngineFunctions.fME_prepNode(): entered pVersion: " & pVersion &
                    " pNodeID: " & pNodeID
                })
            );
            
            If(gblPF_DEBUG_EVAL,
                // THEN
                With(
                    LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
            
                    With(
                        {
                            theCurrentMoveTreeNode: LookUp(colPF_MOVE_TREE, nodeID=pNodeID),
                            theParentMoveTreeNode:  LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_MOVE_TREE, nodeID=pNodeID).parentNodeID),
                            theMoveHistoryTailNode:
                                If(CountRows(colPF_MOVE_HISTORY)>=1,LookUp(colPF_MOVE_HISTORY, nodeID=theData.chessEngineData.moveHistoryTAILNodeID),Blank())
                        } As localVars,
            
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                            " CountRows(colPF_MOVE_HISTORY): " & CountRows(colPF_MOVE_HISTORY)
                        });
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                            " current nodeID: " & pNodeID &
                            " pacn: " & localVars.theCurrentMoveTreeNode.inactiveColorMoveRecord.pacn &
                            " preMove-active color: " & UDF_ColorToStr(UDF_FEN_TO_ACTIVE_COLOR(localVars.theCurrentMoveTreeNode.preMoveFEN)) &
                            " postMovePINs: " & localVars.theCurrentMoveTreeNode.postMovePINs
                        });
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                            " parent nodeID: " & If(IsBlank(localVars.theParentMoveTreeNode),"Blank", localVars.theParentMoveTreeNode.nodeID) &
                            " pacn: " & If(IsBlank(localVars.theParentMoveTreeNode),"Blank", localVars.theParentMoveTreeNode.inactiveColorMoveRecord.pacn) &
                            " preMove-active color: " &
                                If(IsBlank(localVars.theParentMoveTreeNode),"Blank", UDF_ColorToStr(UDF_FEN_TO_ACTIVE_COLOR(localVars.theParentMoveTreeNode.preMoveFEN))) &
                            " postMovePINs: " & If(IsBlank(localVars.theParentMoveTreeNode),"Blank", localVars.theParentMoveTreeNode.postMovePINs)
                        });
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                            " History tail nodeID: " & If(IsBlank(localVars.theMoveHistoryTailNode),"Blank",localVars.theMoveHistoryTailNode.nodeID) &
                            " pacn: " &
                                If(IsBlank(localVars.theMoveHistoryTailNode),"Blank",localVars.theMoveHistoryTailNode.inactiveColorMoveRecord.pacn) &
                            " preMove-active color: " &
                                If(IsBlank(localVars.theMoveHistoryTailNode),"Blank",UDF_ColorToStr(UDF_FEN_TO_ACTIVE_COLOR(localVars.theMoveHistoryTailNode.preMoveFEN))) &
                            " postMovePINs: " & 
                                If(IsBlank(localVars.theMoveHistoryTailNode),"Blank",localVars.theMoveHistoryTailNode.postMovePINs)
                        })
                    )
                )
            );
            
            With(
                LookUp(colPF_MOVE_TREE, nodeID=pNodeID) As theCurrentNode,
            
                With(
                    {
                        postMoveBoard:      UDF_FEN_TO_BOARD(theCurrentNode.postMoveFEN)
                    } As localVars,
            
                    If(gblPF_DEBUG_EVAL,
                        // THEN
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                            " pre-update whiteStrongSqBoard: " & theCurrentNode.postMoveEvalRecord.whiteStrongSqBoard
                        });
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                            " pre-update blackStrongSqBoard: " & theCurrentNode.postMoveEvalRecord.blackStrongSqBoard
                        });
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                            " postMoveBoard: " & localVars.postMoveBoard
                        });
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                            " postMovePINs: " & theCurrentNode.postMovePINs
                        })
                    );
            
                    If(IsBlank(theCurrentNode.postMoveEvalRecord.whiteStrongSqBoard),
                        // THEN - need to populate the whiteStrongSqBoard board
                        With(
                            {
                                whiteStrongSqNameList:
                                    Concat(
                                        Distinct(
                                            Sort(
                                                Split(
                                                    Trim(
                                                        Concat(
                                                            ForAll(
                                                                Sequence(64,0) As theSqNum,
            
                                                                With(
                                                                    {
                                                                        moveBit: UDF_getBitAtSqNum(localVars.postMoveBoard,theSqNum.Value) 
                                                                    } As theMoveBit,
            
                                                                    If(theMoveBit.moveBit=EMPTY_FILLER_ABBR || theMoveBit.moveBit exactin "kqrbnp",
                                                                        // THEN - there is no piece
                                                                        "",
            
                                                                        // THEN - we got a piece - get its' moves and filter them
                                                                        Concat(
                                                                            ForAll(
                                                                                Filter(colPF_LEGAL_MOVES,
                                                                                    sqNum=theSqNum.Value &&
                                                                                    // the PAWN is case sensitive since it is uni-directional
                                                                                    pieceUpper= If(theMoveBit.moveBit in "P",theMoveBit.moveBit,Upper(theMoveBit.moveBit))
                                                                                ) As theEligibleMove,
            
                                                                                Switch(true,
                                                                                    // pawn forward moves do not capture therefore do not make strong squares
                                                                                    theMoveBit.moveBit in "P" && Text(theEligibleMove.theDirection) in "15",
                                                                                        "",
            
                                                                                    // castle moves do not capture therefore do not make strong squares
                                                                                    theEligibleMove.castle<>"-",
                                                                                        "",
            
                                                                                    // make sure slider squares are unoccupied
                                                                                    (!IsBlank(theEligibleMove.slideOvers)) &&
                                                                                        (!IsEmpty(
                                                                                            Filter(
                                                                                                ForAll (
                                                                                                    Split(theEligibleMove.slideOvers, " ") As theSlideOverSqName,
                                                                                
                                                                                                    If(
                                                                                                        UDF_getBitAtSqNum(
                                                                                                            localVars.postMoveBoard, 
                                                                                                            UDF_sqNameToSqNum(theSlideOverSqName.Value)
                                                                                                        ) in "KQRBNP", // any piece of any color in slide zone ?
                                                                                                        true,
                                                                                                        false
                                                                                                    )
                                                                                                ), Value=true
                                                                                            )
                                                                                        )),
                                                                                        "",
            
                                                                                    // default
                                                                                    theEligibleMove.eligibleSqName
                                                                                )
                                                                            ), Value, " "
                                                                        )
                                                                    )
                                                                )
                                                            ), Value, " "
                                                        )
                                                    ), " "
                                                ), Value
                                            ), Value
                                        ), Value, " "
                                    )
                            } As theLists,
            
                            If(gblPF_DEBUG_EVAL,
                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                    " comChessEngineFunctions.fME_prepNode(): DEBUG whiteStrongSqNameList: " & theLists.whiteStrongSqNameList
                                });
                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                    " comChessEngineFunctions.fME_prepNode(): DEBUG postMovePINs: " & theCurrentNode.postMovePINs &
                                    " postMovePINDirections: " & theCurrentNode.postMovePINDirections
                                });
                            );
            
                            UpdateIf(colPF_MOVE_TREE, nodeID=pNodeID, {
                                postMoveEvalRecord: 
                                    Patch(theCurrentNode.postMoveEvalRecord, {
                                        whiteStrongSqBoard: Concat(
                                                                ForAll(
                                                                    Sequence(64,0) As theSqNum,
            
                                                                    If(UDF_sqNumToSqName(theSqNum.Value) in theLists.whiteStrongSqNameList, ATTACKED_ABBR, EMPTY_FILLER_ABBR)
                                                                ), Value, ""
                                                            )
                                    })
                            })
                        )
                    );
            
                    If(IsBlank(theCurrentNode.postMoveEvalRecord.blackStrongSqBoard),
                        // THEN - need to populate the blackStrongSqBoard board
                        With(
                            {
                                blackStrongSqNameList:
                                    Concat(
                                        Distinct(
                                            Sort(
                                                Split(
                                                    Trim(
                                                        Concat(
                                                            ForAll(
                                                                Sequence(64,0) As theSqNum,
            
                                                                With(
                                                                    {
                                                                        moveBit: UDF_getBitAtSqNum(localVars.postMoveBoard,theSqNum.Value) 
                                                                    } As theMoveBit,
            
                                                                    If(theMoveBit.moveBit=EMPTY_FILLER_ABBR || theMoveBit.moveBit exactin "KQRBNP",
                                                                        // THEN - there is no piece
                                                                        "",
            
                                                                        // THEN - we got a piece - get its' moves and filter them
                                                                        Concat(
                                                                            ForAll(
                                                                                Filter(colPF_LEGAL_MOVES,
                                                                                    sqNum=theSqNum.Value &&
                                                                                    // the PAWN is case sensitive since it is uni-directional
                                                                                    pieceUpper= If(theMoveBit.moveBit in "P",theMoveBit.moveBit,Upper(theMoveBit.moveBit))
                                                                                ) As theEligibleMove,
                                                                                
                                                                                Switch(true,
                                                                                    // pawn forward moves do not capture therefore do not make strong squares
                                                                                    theMoveBit.moveBit in "P" && Text(theEligibleMove.theDirection) in "15",
                                                                                        "",
            
                                                                                    // castle moves do not capture therefore do not make strong squares
                                                                                    theEligibleMove.castle<>"-",
                                                                                        "",
            
                                                                                    // make sure slider squares are unoccupied
                                                                                    (!IsBlank(theEligibleMove.slideOvers)) &&
                                                                                        (!IsEmpty(
                                                                                            Filter(
                                                                                                ForAll (
                                                                                                    Split(theEligibleMove.slideOvers, " ") As theSlideOverSqName,
                                                                                
                                                                                                    If(
                                                                                                        UDF_getBitAtSqNum(
                                                                                                            localVars.postMoveBoard, 
                                                                                                            UDF_sqNameToSqNum(theSlideOverSqName.Value)
                                                                                                        ) in "KQRBNP", // any piece of any color in slide zone ?
                                                                                                        true,
                                                                                                        false
                                                                                                    )
                                                                                                ), Value=true
                                                                                            )
                                                                                        )),
                                                                                        "",
            
                                                                                    // default
                                                                                    theEligibleMove.eligibleSqName
                                                                                )
                                                                            ), Value, " "
                                                                        )
                                                                    )
                                                                )
                                                            ), Value, " "
                                                        )
                                                    ), " "
                                                ), Value
                                            ), Value
                                        ), Value, " "
                                    )
                            } As theLists,
            
                            If(gblPF_DEBUG_EVAL,
                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                    " comChessEngineFunctions.fME_prepNode(): DEBUG blackStrongSqList: " & theLists.blackStrongSqNameList
                                })
                            );
            
                            UpdateIf(colPF_MOVE_TREE, nodeID=pNodeID, {
                                postMoveEvalRecord: 
                                    Patch(theCurrentNode.postMoveEvalRecord, {
                                        blackStrongSqBoard: Concat(
                                                                ForAll(
                                                                    Sequence(64,0) As theSqNum,
            
                                                                    If(UDF_sqNumToSqName(theSqNum.Value) in theLists.blackStrongSqNameList, ATTACKED_ABBR, EMPTY_FILLER_ABBR)
                                                                ), Value, ""
                                                            )
                                    })
                            })
                        )
                    )
                )
            );
            
            If(gblPF_DEBUG_EVAL,
                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                    " comChessEngineFunctions.fME_prepNode(): exiting"
                })
            );
            
        ZIndex: =2

