Chess_Board As screen:

    conEntireScreen As groupContainer.manualLayoutContainer:
        Height: =Parent.Height
        Width: =Parent.Width
        ZIndex: =1

        conChessBoardWithCoordinates As groupContainer.manualLayoutContainer:
            BorderThickness: =2
            Height: =560
            Width: =560
            X: =10
            Y: =120
            ZIndex: =1

            galFileBottomLabels As gallery.galleryHorizontal:
                BorderColor: =RGBA(166, 166, 166, 1)
                Height: =40
                Items: |
                    =With(
                        {
                            table: 
                                Sort(
                                    AddColumns(
                                        RenameColumns(Sequence(8),Value,Rank), File,Mid("abcdefgh",Rank,1)
                                    ),
                                    File,SortOrder.Ascending
                                )
                        },
                        table
                    )
                LoadingSpinner: =LoadingSpinner.Data
                ShowScrollbar: =false
                TemplatePadding: =0
                TemplateSize: =60
                Width: =480
                X: =40
                Y: =520
                ZIndex: =1

                lblFileBottom As label:
                    Align: =Align.Center
                    BorderColor: =RGBA(0, 0, 0, 0)
                    BorderThickness: =2
                    Font: =Font.'Courier New'
                    Height: =Parent.TemplateHeight
                    OnSelect: =Select(Parent)
                    Size: =18
                    Text: =ThisItem.File
                    Width: =Parent.TemplateWidth
                    ZIndex: =1

            galFileTopLabels As gallery.galleryHorizontal:
                AccessibleLabel: ="test"
                BorderColor: =RGBA(166, 166, 166, 1)
                Height: =40
                Items: |
                    =With(
                        {
                            table: 
                                Sort(
                                    AddColumns(
                                        RenameColumns(Sequence(8),Value,Rank), File,Mid("abcdefgh",Rank,1)
                                    ),
                                    File,SortOrder.Ascending
                                )
                        },
                        table
                    )
                LoadingSpinner: =LoadingSpinner.Data
                ShowScrollbar: =false
                TemplatePadding: =0
                TemplateSize: =60
                Width: =480
                X: =40
                ZIndex: =2

                lblFileTop As label:
                    Align: =Align.Center
                    BorderColor: =RGBA(0, 0, 0, 0)
                    BorderThickness: =2
                    Color: =RGBA(51, 51, 51, 1)
                    Font: =Font.'Courier New'
                    Height: =Parent.TemplateHeight
                    OnSelect: =Select(Parent)
                    Size: =18
                    Text: =ThisItem.File
                    Width: =Parent.TemplateWidth
                    ZIndex: =1

            galRankRightLabels As gallery.galleryVertical:
                BorderColor: =RGBA(166, 166, 166, 1)
                Height: =480
                Items: |-
                    =With(
                        {
                            table: 
                                Sort(
                                    AddColumns(
                                        RenameColumns(Sequence(8),Value,Rank),
                                        File,Mid("abcdefgh",Rank,1)
                                    ),
                                    File,SortOrder.Descending
                                )
                        },
                        table
                    )
                Layout: =Layout.Vertical
                LoadingSpinner: =LoadingSpinner.Data
                ShowScrollbar: =false
                TemplatePadding: =0
                TemplateSize: =60
                Width: =40
                X: =520
                Y: =40
                ZIndex: =3

                lblRankRight As label:
                    Align: =Align.Center
                    BorderColor: =RGBA(0, 0, 0, 0)
                    BorderThickness: =2
                    Color: =RGBA(51, 51, 51, 1)
                    Font: =Font.'Courier New'
                    Height: =Parent.TemplateHeight
                    OnSelect: =Select(Parent)
                    Size: =18
                    Text: =Text(ThisItem.Rank)
                    Width: =Parent.TemplateWidth
                    ZIndex: =1

            galRankLeftLabels As gallery.galleryVertical:
                BorderColor: =RGBA(166, 166, 166, 1)
                DelayItemLoading: =true
                Height: =480
                Items: |-
                    =With(
                        {
                            table: 
                                Sort(
                                    AddColumns(
                                        RenameColumns(Sequence(8),Value,Rank),
                                        File,Mid("abcdefgh",Rank,1)
                                    ),
                                    File,SortOrder.Descending
                                )
                        },
                        table
                    )
                Layout: =Layout.Vertical
                LoadingSpinner: =LoadingSpinner.Data
                ShowScrollbar: =false
                TemplatePadding: =0
                TemplateSize: =60
                Width: =40
                Y: =40
                ZIndex: =4

                lblRankLeft As label:
                    Font: =Font.'Courier New'
                    Height: =Parent.TemplateHeight
                    OnSelect: =Select(Parent)
                    Size: =18
                    Text: =Text(ThisItem.Rank)
                    Width: =30
                    ZIndex: =1

            conChessBoard As groupContainer.manualLayoutContainer:
                BorderThickness: =1
                Height: =480
                Width: =480
                X: =40
                Y: =40
                ZIndex: =5

                galChessBoard As gallery.galleryVertical:
                    DelayItemLoading: =true
                    Height: =480
                    Items: =Sequence(64,0)
                    Layout: =Layout.Vertical
                    LoadingSpinner: =LoadingSpinner.Data
                    ShowScrollbar: =false
                    TemplatePadding: =0
                    TemplateSize: =60
                    Width: =480
                    WrapCount: =8
                    ZIndex: =1

                    lblSquare As label:
                        Align: =Align.Center
                        BorderColor: |+
                            =If(ThisItem.Value=gblPF_UI_selectedSqNum,
                                // THEN
                                SQUARE_BORDER_COLOR_SELECTED,
                            
                                // ELSE 
                                If(
                                    // THEN - which color is active ?
                                    If(gblPF_UI_GameTurn=WHITE,
                                        // THEN - need to add 8 to target square for en passant
                                        IsBlank(
                                            LookUp(colPF_MOVE_TREE, 
                                                (nodeDepth=1) && (inactiveColorMoveRecord.sourceSquareNum=gblPF_UI_selectedSqNum) && (inactiveColorMoveRecord.targetSquareNum=ThisItem.Value) &&
                                                (
                                                    // a standard capture
                                                    (inactiveColorMoveRecord.targetSquarePieceColor<>NO_COLOR) ||
                                                    // an en passant capture
                                                    ((inactiveColorMoveRecord.targetSquarePieceColor=NO_COLOR)  && (inactiveColorMoveRecord.captureSquareNum=inactiveColorMoveRecord.targetSquareNum+8))
                                                )
                                            )
                                        ),
                            
                                        // ELSE - need to subtract 8 to target square for en passant
                                        IsBlank(
                                            LookUp(colPF_MOVE_TREE, 
                                                (nodeDepth=1) && (inactiveColorMoveRecord.sourceSquareNum=gblPF_UI_selectedSqNum) && (inactiveColorMoveRecord.targetSquareNum=ThisItem.Value) &&
                                                (
                                                    // a standard capture
                                                    (inactiveColorMoveRecord.targetSquarePieceColor<>NO_COLOR) ||
                                                    // an en passant capture
                                                    ((inactiveColorMoveRecord.targetSquarePieceColor=NO_COLOR)  && (inactiveColorMoveRecord.captureSquareNum=inactiveColorMoveRecord.targetSquareNum-8))
                                                )
                                            )
                                        )
                                    ),
                                    Self.Color,
                                    Color.Red
                                )
                            )
                            
                        BorderThickness: =2
                        Fill: |
                            =
                            
                            If(Mod(RoundDown(ThisItem.Value/8,0),2)=0,
                                If(
                                    Or(RoundDown(Mod(ThisItem.Value,2),0),Mod(RoundDown(ThisItem.Value/8,0),2)),
                                    If(gblPF_UI_selectedSqNum=ThisItem.Value,SQUARE_DARK_COLOR_SELECTED,SQUARE_DARK_COLOR),
                                    If(gblPF_UI_selectedSqNum=ThisItem.Value,SQUARE_LIGHT_COLOR_SELECTED,SQUARE_LIGHT_COLOR)
                                ),
                                If(
                                    And(RoundDown(Mod(ThisItem.Value,2),0),Mod(RoundDown(ThisItem.Value/8,0),2)),
                                    If(gblPF_UI_selectedSqNum=ThisItem.Value,SQUARE_LIGHT_COLOR_SELECTED,SQUARE_LIGHT_COLOR),
                                    If(gblPF_UI_selectedSqNum=ThisItem.Value,SQUARE_DARK_COLOR_SELECTED,SQUARE_DARK_COLOR)
                                )
                            )
                            /*
                            IfError(
                                With(
                                    LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                            
                                    If(Mod(RoundDown(ThisItem.Value/8,0),2)=0,
                                        If(
                                            Or(RoundDown(Mod(ThisItem.Value,2),0),Mod(RoundDown(ThisItem.Value/8,0),2)),
                                            If(theData.uiData.UI_sourceSqNum=ThisItem.Value,SQUARE_DARK_COLOR_SELECTED,SQUARE_DARK_COLOR),
                                            If(theData.uiData.UI_sourceSqNum=ThisItem.Value,SQUARE_LIGHT_COLOR_SELECTED,SQUARE_LIGHT_COLOR)
                                        ),
                                        If(
                                            And(RoundDown(Mod(ThisItem.Value,2),0),Mod(RoundDown(ThisItem.Value/8,0),2)),
                                            If(theData.uiData.UI_sourceSqNum=ThisItem.Value,SQUARE_LIGHT_COLOR_SELECTED,SQUARE_LIGHT_COLOR),
                                            If(theData.uiData.UI_sourceSqNum=ThisItem.Value,SQUARE_DARK_COLOR_SELECTED,SQUARE_DARK_COLOR)
                                        )
                                    )
                                ),
                                If(Mod(RoundDown(ThisItem.Value/8,0),2)=0,
                                    If(
                                        Or(RoundDown(Mod(ThisItem.Value,2),0),Mod(RoundDown(ThisItem.Value/8,0),2)),
                                        SQUARE_DARK_COLOR,
                                        SQUARE_LIGHT_COLOR
                                    ),
                                    If(
                                        And(RoundDown(Mod(ThisItem.Value,2),0),Mod(RoundDown(ThisItem.Value/8,0),2)),
                                        SQUARE_LIGHT_COLOR,
                                        SQUARE_DARK_COLOR
                                    )
                                )
                            )
                             */
                        FocusedBorderThickness: =8
                        Height: =58
                        HoverBorderColor: |-
                            =If(gblPF_UI_Ready4Input,
                                // if the square is occupied by a piece of the active color change the border when hovered over
                                With(
                                    LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                            
                                    With(
                                        LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                            
                                        If(gblPF_UI_selectedSqNum=EMPTY_SQUARE_NUM && UDF_PieceToIcon(UDF_getBitAtSqNum(gblPF_UI_DisplayedBoard, ThisItem.Value))=EMPTY_ICON,
                                            Self.Fill,
                                            If(
                                                gblPF_UI_selectedSqNum=EMPTY_SQUARE_NUM &&
                                                UDF_PieceToIcon(UDF_getBitAtSqNum(gblPF_UI_DisplayedBoard, ThisItem.Value))<>EMPTY_ICON && 
                                                UDF_PieceToColor(UDF_getBitAtSqNum(gblPF_UI_DisplayedBoard, ThisItem.Value))=gblPF_UI_GameTurn,
                                                SQUARE_BORDER_COLOR_HOVER,
                                                Self.Fill
                                            )
                                        )
                                    )
                                )
                            )
                        HoverColor: |-
                            =If(gblPF_UI_Ready4Input,
                                If(ThisItem.Value=gblPF_UI_selectedSqNum,
                                    // THEN
                                    SQUARE_BORDER_COLOR_SELECTED,
                            
                                    // ELSE 
                                    If(
                                        // THEN - which color is active ?
                                        If(gblPF_UI_GameTurn=WHITE,
                                            // THEN - need to add 8 to target square for en passant
                                            IsBlank(
                                                LookUp(colPF_MOVE_TREE, 
                                                    (nodeDepth=1) && (inactiveColorMoveRecord.sourceSquareNum=gblPF_UI_selectedSqNum) && (inactiveColorMoveRecord.targetSquareNum=ThisItem.Value) &&
                                                    (
                                                        // a standard capture
                                                        (inactiveColorMoveRecord.targetSquarePieceColor<>NO_COLOR) ||
                                                        // an en passant capture
                                                        ((inactiveColorMoveRecord.targetSquarePieceColor=NO_COLOR)  && (inactiveColorMoveRecord.captureSquareNum=inactiveColorMoveRecord.targetSquareNum+8))
                                                    )
                                                )
                                            ),
                            
                                            // ELSE - need to subtract 8 to target square for en passant
                                            IsBlank(
                                                LookUp(colPF_MOVE_TREE, 
                                                    (nodeDepth=1) && (inactiveColorMoveRecord.sourceSquareNum=gblPF_UI_selectedSqNum) && (inactiveColorMoveRecord.targetSquareNum=ThisItem.Value) &&
                                                    (
                                                        // a standard capture
                                                        (inactiveColorMoveRecord.targetSquarePieceColor<>NO_COLOR) ||
                                                        // an en passant capture
                                                        ((inactiveColorMoveRecord.targetSquarePieceColor=NO_COLOR)  && (inactiveColorMoveRecord.captureSquareNum=inactiveColorMoveRecord.targetSquareNum-8))
                                                    )
                                                )
                                            )
                                        ),
                                        Self.Color,
                                        Color.Red
                                    )
                                ),
                                Self.Color
                            )
                        OnSelect: |+
                            =/*
                            Use Cases:
                                - Use Case #0 (Not ready to play)  - do not accept any input
                                - Use Case #1 (1st click on empty square) gblPF_UI_selectedSqNum is EMPTY SQUARE NUM AND you clicked on an empty square and do nothing
                                - Use Case #2 (a.k.a., unselect) Use Case #2 gblPF_UI_selectedSqNum is NOT EMPTY_SQUARE_NUM AND gblPF_UI_selectedSqNum IS the square you clicked on unselect the current square
                                - Use Case #3 (a.k.a., move to unoccupied square) gblPF_UI_selectedSqNum is NOT EMPTY_SQUARE_NUM AND gblPF_UI_selectedSqNum is NOT the square you clicked on AND you clicked on an empty square then this is a move to an empty square
                            
                                - Use Case #4 (a.k.a., 1st click) if clicked square is NOT already selected AND  if clicked square is occupied by a piece of the same color as the active color then select the clicked square
                                    - and any O icons and target borders get cleared out as well
                                    - the gblPF_UI_selectedSqNum gets set to EMPTY_SQUARE_NUM
                            
                                - Use Case #6 (1st click on wrong color) if gblPF_UI_selectedSqNum is EMPTY SQUARE NUM AND you clicked on a square occupied by a piece of the inactive color then do nothing
                                - Use Case #7 (a.k.a., capture move) gblPF_UI_selectedSqNum is NOT EMPTY_SQUARE_NUM AND if you clicked on a square occupied by a piece of the inactive color then this is a capture move
                             */
                            Select(Parent);
                            
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                "lblSquare_BCB.OnSelect(): entered"
                            });
                            
                            With(
                                LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                            
                                With(
                                    LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID) As theCurrentNode,
                            
                                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                        "lblSquare_BCB.OnSelect(): click detected on squareNum: " & ThisItem.Value &
                                        " gblPF_UI_selectedSqNum: " & gblPF_UI_selectedSqNum &
                                        " gblPF_UI_Ready4Input: " & gblPF_UI_Ready4Input
                                    });
                            
                                    Switch(true,    
                                        // -------  USE CASE #0 CHECK (Not ready to play) ---------------------------------------------------------------------------------------------------
                                        Not(gblPF_UI_Ready4Input),
                            
                                            // Use Case #0 (Not ready to play) - do not accept any input
                                            UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                            diagnosticText:     "Use Case #0: Not ready for user input - ignoring the click.",
                                                            diagnosticFill:     COLOR_YELLOWish
                                                        })
                                            });
                                            Blank(),
                            
                                        // -------  USE CASE #1 CHECK (1st click on empty square) ---------------------------------------------------------------------------------------------------
                                        gblPF_UI_selectedSqNum=EMPTY_SQUARE_NUM && UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theCurrentNode.postMoveFEN), ThisItem.Value)=EMPTY_FILLER_ABBR, 
                            
                                            // Use Case #1 (1st click on empty square) gblPF_UI_selectedSqNum is EMPTY SQUARE NUM AND you clicked on an empty square and do nothing
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " lblSquare_BCB.OnSelect(): Use Case #1 (1st click on empty square) detected ThisItem.Value: " & ThisItem.Value
                                            });
                                            UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                            diagnosticText:     "Use Case #1: empty square selected as the source square - ignoring selection.",
                                                            diagnosticFill:     COLOR_GREENish
                                                        })
                                            }),
                            
                                        // -------  USE CASE #2 CHECK (a.k.a., unselect) ---------------------------------------------------------------------------------------------------
                                        gblPF_UI_selectedSqNum<>EMPTY_SQUARE_NUM && gblPF_UI_selectedSqNum=ThisItem.Value, 
                            
                                            // Use Case #2 (a.k.a., unselect) gblPF_UI_selectedSqNum is NOT EMPTY_SQUARE_NUM AND gblPF_UI_selectedSqNum IS the square you clicked on unselect the current square
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                            " lblSquare_BCB.OnSelect(): Use Case #2 (a.k.a., unselect) detected ThisItem.Value: " & ThisItem.Value});
                                            Set(gblPF_UI_selectedSqNum, EMPTY_SQUARE_NUM);
                                            UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                            // UI_sourceSqNum:     EMPTY_SQUARE_NUM,
                                                            diagnosticText:     "Use Case #2: Unselecting selected SquareNum(" & ThisItem.Value & ") ",
                                                            diagnosticFill:     COLOR_GREENish
                                                        })
                                            }),
                            
                                        // -------  USE CASE #3 CHECK (a.k.a., move to unoccupied square) ---------------------------------------------------------------------------------------------------
                                        gblPF_UI_selectedSqNum<>ThisItem.Value && 
                                            UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theCurrentNode.postMoveFEN), ThisItem.Value)=EMPTY_FILLER_ABBR, 
                            
                                            // Use Case #3 (a.k.a., move to unoccupied square) gblPF_UI_selectedSqNum is NOT EMPTY_SQUARE_NUM AND gblPF_UI_selectedSqNum is NOT the square you clicked on AND you clicked on 
                                            // an empty square then this is a move to an empty square
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                " lblSquare_BCB.OnSelect(): Use Case #3 (a.k.a., move to unoccupied square) detected gblPF_UI_selectedSqNum: " & gblPF_UI_selectedSqNum & 
                                                " ThisItem.Value: " & ThisItem.Value
                                            });
                            
                                            // see if this is a valid square - if so make the move
                                            With(
                                                LookUp(colPF_MOVE_TREE, 
                                                    nodeDepth=1 && inactiveColorMoveRecord.sourceSquareNum=gblPF_UI_selectedSqNum && inactiveColorMoveRecord.targetSquareNum=ThisItem.Value &&
                                                    (inactiveColorMoveRecord.promoteTo=EMPTY_ABBR || inactiveColorMoveRecord.promoteTo in "Q")
                                                ) As theMoveTreeRecord,
                            
                                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                    "lblSquare_BCB.OnSelect(): Use Case #3 (a.k.a., move to unoccupied square) invalid move detected sourceSquareNum: " & 
                                                    gblPF_UI_selectedSqNum & " ThisItem.Value: " & ThisItem.Value &
                                                    " targetSquareNum (from moveTree) : " &  theMoveTreeRecord.inactiveColorMoveRecord.targetSquareNum &
                                                    " san: " & theMoveTreeRecord.inactiveColorMoveRecord.san & " IsBlank(theMoveTreeRecord): " & IsBlank(theMoveTreeRecord)
                                                });
                            
                                                If(IsBlank(theMoveTreeRecord),
                                                    // THEN - not a valid move
                                                    UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                        uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                                    diagnosticText:     "Use Case #3: Invalid move - please try again ",
                                                                    diagnosticFill:     COLOR_YELLOWish
                                                                })
                                                    }),
                            
                                                    // ELSE - valid move - make the move
                                                    Set(gblPF_UI_selectedSqNum, EMPTY_SQUARE_NUM);
                                                    Set(gblPF_UI_Ready4Input, false);
                                                    UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                        uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                                    // UI_sourceSqNum:     EMPTY_SQUARE_NUM,
                                                                    // UI_ready4Input:     false,
                                                                    diagnosticText:     "Use Case #3: Processing the Player move -> san: " & theMoveTreeRecord.inactiveColorMoveRecord.san & 
                                                                                        " pacn: " & theMoveTreeRecord.inactiveColorMoveRecord.pacn,
                                                                    diagnosticFill:     COLOR_GREENish
                                                                }),
                                                        chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                                pacn:     theMoveTreeRecord.inactiveColorMoveRecord.pacn
                                                                            })
                                                    });
                            
                                                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                        "lblSquare_BCB.OnSelect(): Use Case #3 (a.k.a., move to unoccupied square) calling Select(btnProcessGame) "
                                                    });
                                                    Select(btnProcessGame)
                                                )
                                            ),
                            
                                        // -------  USE CASE #4 CHECK (a.k.a., 1st click) ---------------------------------------------------------------------------------------------------
                                        gblPF_UI_selectedSqNum<>ThisItem.Value && 
                                            UDF_PieceToColor(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theCurrentNode.postMoveFEN), ThisItem.Value))=UDF_FEN_TO_ACTIVE_COLOR(theCurrentNode.postMoveFEN), 
                            
                                            // Use Case #4 (a.k.a., 1st click) if clicked square is NOT already selected AND  if clicked square is occupied by a piece of 
                                            //      the same color as the active color then select the clicked square
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                "lblSquare_BCB.OnSelect(): Use Case #4 (a.k.a., 1st click) detected ThisItem.Value: " & ThisItem.Value &
                                                " CountRows(Filter(colPF_MOVE_TREE, nodeDepth=1 && inactiveColorMoveRecord.sourceSquareNum=ThisItem.Value)): " &
                                                    CountRows(Filter(colPF_MOVE_TREE, nodeDepth=1 && inactiveColorMoveRecord.sourceSquareNum=ThisItem.Value))
                                            });
                            
                                            // let's make sure the piece can be selected (i.e., there are some valid moves for it) before we mark it as selected
                                            If(CountRows(Filter(colPF_MOVE_TREE, nodeDepth=1 && inactiveColorMoveRecord.sourceSquareNum=ThisItem.Value))>0, 
                                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                    " CountRows(Filter(colPF_MOVE_TREE, nodeDepth=1 && inactiveColorMoveRecord.sourceSquareNum=ThisItem.Value)) is > 0" &
                                                    " ThisItem.Value: " & ThisItem.Value
                                                });
                                                Set(gblPF_UI_selectedSqNum, ThisItem.Value);
                                                UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                    uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                                // UI_sourceSqNum:     ThisItem.Value,
                                                                diagnosticText:     "Use Case #4: Selecting SquareNum(" & ThisItem.Value & ") " & UDF_sqNumToSqName(ThisItem.Value) & 
                                                                                    " as source square of the move.",
                                                                diagnosticFill:     COLOR_GREENish
                                                            })
                                                }),
                            
                                                
                                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                    " CountRows(Filter(colPF_MOVE_TREE, nodeDepth=1 && inactiveColorMoveRecord.sourceSquareNum=ThisItem.Value)) is <= 0" &
                                                    " ThisItem.Value: " & ThisItem.Value
                                                });
                            
                                                Set(gblPF_UI_selectedSqNum, EMPTY_SQUARE_NUM);
                                                UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                    uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                                // UI_sourceSqNum:     EMPTY_SQUARE_NUM,
                                                                diagnosticText:     "Use Case #4: No valid move associated with source SquareNum(" & ThisItem.Value & ") " & 
                                                                                    UDF_sqNumToSqName(ThisItem.Value) & " ignoring click.",
                                                                diagnosticFill:     COLOR_YELLOWish
                                                            })
                                                })
                                            ),
                            
                                        // -------  USE CASE #6 CHECK (1st click on wrong color) -----------------------------------------------------------------------------------------------
                                        gblPF_UI_selectedSqNum=EMPTY_SQUARE_NUM && 
                                            UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theCurrentNode.postMoveFEN), ThisItem.Value)<>EMPTY_FILLER_ABBR &&
                                            UDF_PieceToColor(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theCurrentNode.postMoveFEN), ThisItem.Value))<>UDF_FEN_TO_ACTIVE_COLOR(theCurrentNode.postMoveFEN), 
                            
                                            // Use Case #6 (1st click on wrong color) if gblPF_UI_selectedSqNum is EMPTY SQUARE NUM AND you clicked on a square occupied by a piece of the inactive color then do nothing
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                "lblSquare_BCB.OnSelect(): Use Case #6 (1st click on wrong color) detected ThisItem.Value: " & ThisItem.Value
                                            });
                                            Set(gblPF_UI_selectedSqNum, EMPTY_SQUARE_NUM);
                                            UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                            // UI_sourceSqNum:     EMPTY_SQUARE_NUM,
                                                            diagnosticText:     "Use Case #6: 1st click on wrong color piece SquareNum(" & ThisItem.Value & ") " & 
                                                                                UDF_sqNumToSqName(ThisItem.Value) & " ignoring click.",
                                                            diagnosticFill:     COLOR_YELLOWish
                                                        })
                                            }),
                            
                                        // -------  USE CASE #7 CHECK (a.k.a., capture move) ---------------------------------------------------------------------------------------------------
                                        gblPF_UI_selectedSqNum<>EMPTY_SQUARE_NUM && 
                                            UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theCurrentNode.postMoveFEN), ThisItem.Value)<>EMPTY_FILLER_ABBR &&
                                            UDF_PieceToColor(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theCurrentNode.postMoveFEN), ThisItem.Value))<>UDF_FEN_TO_ACTIVE_COLOR(theCurrentNode.postMoveFEN),
                            
                                            // Use Case #7 (a.k.a., capture move) gblPF_UI_selectedSqNum is NOT EMPTY_SQUARE_NUM AND if you clicked on a square occupied by a piece 
                                            // of the inactive color then this is a capture move
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                "lblSquare_BCB.OnSelect(): Use Case #7 (a.k.a., capture move) detected ThisItem.Value: " & ThisItem.Value
                                            });
                            
                                            // see if this is a valid square - if so make the move
                                            With(
                                                LookUp(colPF_MOVE_TREE, 
                                                    nodeDepth=1 && inactiveColorMoveRecord.sourceSquareNum=gblPF_UI_selectedSqNum && inactiveColorMoveRecord.targetSquareNum=ThisItem.Value &&
                                                    (inactiveColorMoveRecord.promoteTo=EMPTY_ABBR || inactiveColorMoveRecord.promoteTo in "Q")
                                                ) As theMoveTreeRecord,
                            
                                                If(IsBlank(theMoveTreeRecord),
                                                    // THEN - not a valid move
                                                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                        "lblSquare_BCB.OnSelect(): Use Case #7 (a.k.a., capture move) invalid move detected sourceSquareNum: " & gblPF_UI_selectedSqNum & 
                                                        " ThisItem.Value: " & ThisItem.Value &
                                                        " targetSquareNum (from moveTree) : " &  theMoveTreeRecord.inactiveColorMoveRecord.targetSquareNum &
                                                        " san: " & theMoveTreeRecord.inactiveColorMoveRecord.san & " IsBlank(theMoveTreeRecord): " & IsBlank(theMoveTreeRecord)
                                                    });
                            
                                                    UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                        uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                                    diagnosticText:     "Use Case #7: no move associated with target square SquareNum(" & ThisItem.Value & ") " & 
                                                                                        UDF_sqNumToSqName(ThisItem.Value) & " ignoring click.",
                                                                    diagnosticFill:     COLOR_YELLOWish
                                                                })
                                                    }),
                            
                                                    // ELSE - valid move - make the move
                                                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                        "lblSquare_BCB.OnSelect(): Use Case #7 (a.k.a., capture move) valid move detected sourceSquareNum: " & gblPF_UI_selectedSqNum & 
                                                        " ThisItem.Value: " & ThisItem.Value &
                                                        " targetSquareNum (from moveTree) : " &  theMoveTreeRecord.inactiveColorMoveRecord.targetSquareNum &
                                                        " san: " & theMoveTreeRecord.inactiveColorMoveRecord.san & 
                                                        " pacn: " & theMoveTreeRecord.inactiveColorMoveRecord.pacn
                                                    });
                            
                                                    Set(gblPF_UI_selectedSqNum, EMPTY_SQUARE_NUM);
                                                    Set(gblPF_UI_Ready4Input, false);
                                                    UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                        uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                                    // UI_sourceSqNum:     EMPTY_SQUARE_NUM,
                                                                    // UI_ready4Input:     false,
                                                                    diagnosticText:     "Use Case #7: Processing the Player move -> san: " & theMoveTreeRecord.inactiveColorMoveRecord.san & 
                                                                                        " pacn: " & theMoveTreeRecord.inactiveColorMoveRecord.pacn,
                                                                    diagnosticFill:     COLOR_GREENish
                                                                }),
                                                        chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                                pacn:     theMoveTreeRecord.inactiveColorMoveRecord.pacn
                                                                            })
                                                    });
                            
                                                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                        "lblSquare_BCB.OnSelect(): Use Case #7 (a.k.a., capture move) calling Select(btnProcessGame) "
                                                    });
                                                    Select(btnProcessGame)
                                                )   
                                            )
                                    )
                                )
                            );
                            
                            
                            
                        PaddingBottom: =0
                        PaddingLeft: =1
                        PaddingRight: =0
                        PaddingTop: =1
                        Size: =24
                        Text: |
                            =UDF_PieceToIcon(
                                UDF_getBitAtSqNum(
                                    gblPF_UI_DisplayedBoard, 
                                    ThisItem.Value
                                )
                            )
                        Width: =58
                        Y: =2
                        ZIndex: =1

        conScoreSheet As groupContainer.manualLayoutContainer:
            Height: =conChessBoardWithCoordinates.Height
            Width: =310
            X: =conChessBoardWithCoordinates.X + conChessBoardWithCoordinates.Width + 10
            Y: =conChessBoardWithCoordinates.Y
            ZIndex: =2

            galScoreSheetPGN As gallery.galleryVertical:
                DelayItemLoading: =true
                Height: =Parent.Height - conScoreSheetHeader.Height
                Items: |
                    =
                    Sequence((LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveNumber + 1)/2,
                        If(IsBlank(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.startingFEN),
                            1,
                            UDF_FEN_TO_FULLMOVE_COUNT(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.startingFEN)
                        )
                    )
                Layout: =Layout.Vertical
                LoadingSpinner: =LoadingSpinner.Data
                TemplateSize: =25
                Width: =Parent.Width
                Y: =35
                ZIndex: =1

                lblScoreSheetPGNLine As label:
                    Font: =Font.'Courier New'
                    Height: =25
                    OnSelect: =Select(Parent)
                    Size: =10
                    Text: |
                        =Right(
                            "     " & 
                            If(IsBlankOrError(ThisItem.Value),"1",ThisItem.Value) & 
                            ". ", 5
                        ) & 
                        Left( 
                            If(IsBlankOrError(LookUp(colPF_MOVE_HISTORY, nodeID>=0 && UDF_FEN_TO_ACTIVE_COLOR(preMoveFEN)=WHITE && UDF_FEN_TO_FULLMOVE_COUNT(preMoveFEN)=ThisItem.Value)),
                                ".",
                                LookUp(colPF_MOVE_HISTORY, 
                                    nodeID>=0 && 
                                    UDF_FEN_TO_ACTIVE_COLOR(preMoveFEN)=WHITE && 
                                    UDF_FEN_TO_FULLMOVE_COUNT(preMoveFEN)=ThisItem.Value
                                ).inactiveColorMoveRecord.san
                            ) & "          ", 10
                        ) & "   |   " &
                        Left( 
                            If(IsBlankOrError(LookUp(colPF_MOVE_HISTORY, nodeID>=0 && UDF_FEN_TO_ACTIVE_COLOR(preMoveFEN)=BLACK && UDF_FEN_TO_FULLMOVE_COUNT(preMoveFEN)=ThisItem.Value)),
                                "...",
                                LookUp(colPF_MOVE_HISTORY,
                                    nodeID>=0 && 
                                    UDF_FEN_TO_ACTIVE_COLOR(preMoveFEN)=BLACK && 
                                    UDF_FEN_TO_FULLMOVE_COUNT(preMoveFEN)=ThisItem.Value
                                ).inactiveColorMoveRecord.san
                            ) & "          ", 10
                        )
                    Width: =300
                    ZIndex: =1

            conScoreSheetHeader As groupContainer.manualLayoutContainer:
                Height: =35
                Width: =Parent.Width
                ZIndex: =2

                lblScoreSheetTitle As label:
                    Align: =Align.Center
                    Fill: =RGBA(215, 223, 240, 1)
                    Height: =35
                    Text: ="Chess Score Sheet"
                    Width: =Parent.Width
                    ZIndex: =1

        conControls As groupContainer.manualLayoutContainer:
            Height: =conChessBoardWithCoordinates.Height
            Width: =(conEntireScreen.X + conEntireScreen.Width) - conChessBoardWithCoordinates.Width - conScoreSheet.Width - 30
            X: =conScoreSheet.X + conScoreSheet.Width + 5
            Y: =conScoreSheet.Y
            ZIndex: =3

            conControlsDiagnostics As groupContainer.manualLayoutContainer:
                Height: =Parent.Height-conControlsSharedArea.Height
                Visible: =Not(conControlsGame.Visible)
                Width: =Parent.Width
                Y: =conControlsSharedArea.Height
                ZIndex: =1

                btnCheckGameTestResults As button:
                    Text: ="Button"
                    Visible: =false
                    X: =40
                    Y: =40
                    ZIndex: =1

                btnCheckTestResults As button:
                    Text: ="Button"
                    Visible: =false
                    ZIndex: =2

            conControlsGame As groupContainer.manualLayoutContainer:
                Height: =Parent.Height-conControlsSharedArea.Height
                Width: =Parent.Width
                Y: =60
                ZIndex: =2

                lblPlayerColorHeader As label:
                    Text: ="Player plays as..."
                    X: =25
                    ZIndex: =1

                lblStartingFEN As label:
                    Text: ="FEN"
                    X: =12
                    Y: =175
                    ZIndex: =2

                lblSelectedSquareNum As label:
                    Font: =Font.'Courier New'
                    Height: =25
                    Size: =10
                    Text: |-
                        ="Selected Square Num:" & If(gblPF_UI_selectedSqNum=64,"None",gblPF_UI_selectedSqNum)
                    Width: =225
                    X: =15
                    Y: =431
                    ZIndex: =4

                lblBoardReadyForInput As label:
                    Font: |-
                        ="Board Ready for Input:"
                    Height: =25
                    Size: =10
                    Text: |-
                        ="Board Ready for Input: " & gblPF_UI_Ready4Input
                    Width: =200
                    X: =12
                    Y: =273
                    ZIndex: =5

                lblBoardGamePhaseHeader As label:
                    Font: =Font.'Courier New'
                    Height: =25
                    Size: =10
                    Text: |-
                        ="Game Phase:"
                    Width: =100
                    X: =15
                    Y: =298
                    ZIndex: =6

                lblBoardGamePhase As label:
                    Font: =Font.'Courier New'
                    Height: =25
                    Size: =11
                    Text: =gblPF_UI_GamePhase
                    Width: =120
                    X: =117
                    Y: =298
                    ZIndex: =7

                txtStartingFEN As text:
                    Default: =""
                    Height: =38
                    Width: =440
                    X: =12
                    Y: =215
                    ZIndex: =8

                btnStartGameFromBeginning As button:
                    Height: =23
                    OnSelect: |
                        =comUtilityFunctionsLibrary.fUtilInitData(100);
                        
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " btnStartGameFromBeginning.OnSelect(): entered player color is: " & radPlayerColor.Selected.Value
                        });
                        
                        UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                            uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                        statusText:         "Game in progress..." ,
                                        statusFill:         COLOR_GREENish,
                                        diagnosticText:     If(radPlayerColor.Selected.Value="White" || radPlayerColor.Selected.Value="Both",
                                                                "Player's Turn coming up",
                                                                "Computer's Turn coming up"
                                                            ),
                                        diagnosticFill:     COLOR_GREENish
                                    }),
                            chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                    startingFEN:    FEN_START_POSITION,
                                                    moveNumber:     0,
                                                    testNumber:     -1,
                                                    testCount:      0,
                                                    isGame:         true,
                                                    playerColor:    Switch(true,
                                                                        radPlayerColor.Selected.Value="White",   WHITE,
                                                                        radPlayerColor.Selected.Value="Black",   BLACK,
                                                                        radPlayerColor.Selected.Value="Both",    BOTH_COLORS,
                                                                        radPlayerColor.Selected.Value="Neither", NEITHER_COLOR
                                                                    )
                                                })
                        });
                        
                        Select(btnNewGame);
                    Size: =8
                    Text: ="Start from Beginning"
                    Width: =125
                    X: =12
                    Y: =104
                    ZIndex: =9

                btnStartGameFromFEN As button:
                    Height: =23
                    OnSelect: |
                        =
                        
                        
                        comUtilityFunctionsLibrary.fUtilInitData(100);
                        
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " btnStartGameFromFEN.OnSelect(): entered player color is: " & radPlayerColor.Selected.Value &
                            " FEN: " & txtStartingFEN.Text
                        });
                        
                        UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                            uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                        UI_ready4Input:     false,
                                        UI_sourceSqNum:     EMPTY_SQUARE_NUM,
                                        statusText:         "Game getting started..." ,
                                        statusFill:         COLOR_GREENish,
                                        diagnosticText:     If(radPlayerColor.Selected.Value="White" || radPlayerColor.Selected.Value="Both",
                                                                "Player's Turn coming up",
                                                                "Computer's Turn coming up"
                                                            ),
                                        diagnosticFill:     COLOR_YELLOWish
                                    }),
                            chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                    startingFEN:    txtStartingFEN.Text,
                                                    moveNumber:     0,
                                                    testNumber:     -1,
                                                    testCount:      0,
                                                    isGame:         true,
                                                    playerColor:    Switch(true,
                                                                        radPlayerColor.Selected.Value="White",   WHITE,
                                                                        radPlayerColor.Selected.Value="Black",   BLACK,
                                                                        radPlayerColor.Selected.Value="Both",    BOTH_COLORS,
                                                                        radPlayerColor.Selected.Value="Neither", NEITHER_COLOR
                                                                    )
                                                })
                        });
                        
                        Select(btnNewGame);
                    Size: =10
                    Text: ="Start from FEN"
                    Width: =125
                    X: =12
                    Y: =137
                    ZIndex: =10

                btnCheckGameResults As button:
                    OnSelect: |
                        =With(
                            LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                        
                            If(theData.chessEngineData.testNumber>=0,
                                // THEN - this is a Game Test
                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                    " btnCheckGameResults.OnSelect(): Game Test detected - redirecting to btnCheckGameTestResults testNumber: " & theData.chessEngineData.testNumber 
                                });
                                Select(btnCheckGameTestResults),
                        
                                // ELSE - this is a Game
                                /* ---------------------------------------------------------------------------------
                                GAME_CHECKMATE
                        
                                - moves 0+
                                - test "current" (move tree D0) position to see if there is a checkmate
                                */
                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                    " btnCheckGameResults.OnSelect(): GAME_CHECKMATE getting started.   vvvvvvvvvvvvvvvvvvvvvvvvvvvvv"
                                });
                        
                                With(
                                    LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                        
                                    // RESULT CHECK - GAME_CHECKMATE
                                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                        " btnCheckGameResults.OnSelect(): GAME_CHECKMATE Move # " & theData.chessEngineData.moveNumber & 
                                        " CHECKMATE: " & 
                                            If(UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE,
                                                theD0ParentNode.postMoveGameStatus.whiteIsCheckmated,
                                                theD0ParentNode.postMoveGameStatus.blackIsCheckmated
                                            )
                                    });
                        
                                    If(theD0ParentNode.postMoveGameStatus.whiteIsCheckmated || theD0ParentNode.postMoveGameStatus.blackIsCheckmated,
                                        // THEN - got some kind of checkmate
                                        Set(gblPF_UI_selectedSqNum, EMPTY_SQUARE_NUM);
                                        Set(gblPF_UI_Ready4Input, false);
                                        UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                            uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                        statusText:
                                                            If(theD0ParentNode.postMoveGameStatus.whiteIsCheckmated,
                                                                "Game Over - Checkmate (Black won)" ,
                                                                "Game Over - Checkmate (White won)"
                                                            ),
                                                        statusFill:         COLOR_WHITEish,
                                                        diagnosticText:     "",
                                                        diagnosticFill:     COLOR_WHITEish
                                                    }),
                                            chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                    isGame:         false
                                                                })
                                        })
                                    )
                                );
                        
                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                    " btnCheckGameResults.OnSelect(): GAME_CHECKMATE finished  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                                });
                        
                                With(
                                    LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                        
                        
                                    If(theData.chessEngineData.isGame,
                                        /* -----------------------------------
                                        GAME_STALEMATE
                        
                                        - moves 0+
                                        - test "current" (move tree D0) position to see if there is a stalemate
                                        */
                                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                            " btnCheckGameResults.OnSelect(): GAME_STALEMATE getting started vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv>"
                                        });
                        
                                        With(
                                            LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                        
                                            // RESULT CHECK - GAME_STALEMATE
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                " btnCheckGameResults.OnSelect(): STALEMATE: " & theD0ParentNode.postMoveGameStatus.isStalemate
                                            });
                        
                                            If(theD0ParentNode.postMoveGameStatus.isStalemate, 
                                                // THEN
                                                Set(gblPF_UI_selectedSqNum, EMPTY_SQUARE_NUM);
                                                Set(gblPF_UI_Ready4Input, false);
                                                UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                    uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                                statusText:         "Game Over - Stalemate." ,
                                                                statusFill:         COLOR_WHITEish,
                                                                diagnosticText:     "",
                                                                diagnosticFill:     COLOR_WHITEish
                                                            }),
                                                    chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                            isGame:         false
                                                                        })
                                                })
                                            )
                                        );
                        
                                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                            " btnCheckGameResults.OnSelect(): GAME_STALEMATE finished   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                                        })
                                    )
                                );
                        
                                With(
                                    LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                        
                        
                                    If(theData.chessEngineData.isGame,
                                        /* -----------------------------------
                                        GAME_DRAW
                        
                                        - moves 0+
                                        - test "current" (move tree D0) position to see if there is a draw
                                        */
                                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                            " btnCheckGameResults.OnSelect(): GAME_DRAW getting started vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv>"
                                        });
                        
                                        With(
                                            LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                        
                                            // RESULT CHECK - GAME_DRAW
                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                " btnCheckGameResults.OnSelect(): DRAW: " & theD0ParentNode.postMoveGameStatus.isDraw
                                            });
                        
                                            If(theD0ParentNode.postMoveGameStatus.isDraw, 
                                                // THEN
                                                Set(gblPF_UI_selectedSqNum, EMPTY_SQUARE_NUM);
                                                Set(gblPF_UI_Ready4Input, false);
                                                UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                    uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                                statusText:         
                                                                    Switch(true,
                                                                        theD0ParentNode.inactiveColorMoveRecord.isISMDraw,  "Game Over - Insufficient Material Draw",
                                                                        theD0ParentNode.inactiveColorMoveRecord.is75MoveDraw,  "Game Over - 75 move Draw",
                        
                                                                        // default
                                                                        "Game Over - 3x repeated position Draw" 
                                                                    ),
                                                                statusFill:         COLOR_WHITEish,
                                                                diagnosticText:     "",
                                                                diagnosticFill:     COLOR_WHITEish
                                                            }),
                                                    chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                            isGame:         false
                                                                        })
                                                })
                                            )
                                        );
                        
                                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                            " btnCheckGameResults.OnSelect(): GAME_DRAW finished   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                                        })
                                    )
                                );
                        
                                With(
                                    LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                        
                                    // are we still playing ?
                                    If(theData.chessEngineData.isGame,
                        
                                        With(
                                            LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID) As theD0Node,
                        
                                            If(UDF_FEN_TO_ACTIVE_COLOR(theD0Node.postMoveFEN)=theData.chessEngineData.playerColor || theData.chessEngineData.playerColor=BOTH_COLORS,
                                                // THEN - it is the player's turn
                                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                    " btnCheckGameResults.OnSelect(): player's turn UDF_FEN_TO_ACTIVE_COLOR(): " & UDF_FEN_TO_ACTIVE_COLOR(theD0Node.postMoveFEN) &
                                                    " playerColor: " & theData.chessEngineData.playerColor
                                                });
                                                Set(gblPF_UI_selectedSqNum, EMPTY_SQUARE_NUM);
                                                Set(gblPF_UI_Ready4Input, true);
                        
                                                UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                    uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                                statusText:         "Game in progress." ,
                                                                statusFill:         COLOR_GREENish,
                                                                diagnosticText:     "Player's turn (" & UDF_ColorToStr(UDF_FEN_TO_ACTIVE_COLOR(theD0Node.postMoveFEN)) & ") - please make a move.",
                                                                diagnosticFill:     COLOR_GREENish
                                                            }),
                                                    chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                            moveNumber: theData.chessEngineData.moveNumber + 1
                                                                        })
                                                }),
                        
                                                // ELSE - it is the computer's turn
                                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                    " btnCheckGameResults.OnSelect(): computer's turn UDF_FEN_TO_ACTIVE_COLOR(): " & UDF_FEN_TO_ACTIVE_COLOR(theD0Node.postMoveFEN) &
                                                    " playerColor: " & theData.chessEngineData.playerColor
                                                });
                                                With(
                                                    First(
                                                        Sort(
                                                            Filter(colPF_MOVE_TREE, nodeDepth=1), 
                                                            postMoveEvalRecord.centipawn, 
                                                            If(UDF_FEN_TO_ACTIVE_COLOR(theD0Node.postMoveFEN)=WHITE,
                                                                SortOrder.Descending,
                                                                SortOrder.Ascending
                                                            )
                                                        )
                                                    ) As theMove,
                        
                                                    Set(gblPF_UI_selectedSqNum, EMPTY_SQUARE_NUM);
                                                    Set(gblPF_UI_Ready4Input, false);
                        
                                                    UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                        uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                                    statusText:         "Game in progress." ,
                                                                    statusFill:         COLOR_GREENish,
                                                                    diagnosticText:     "Computer's turn - please wait while it thinks...",
                                                                    diagnosticFill:     COLOR_WHITEish
                                                                }),
                                                        chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                                moveNumber: theData.chessEngineData.moveNumber + 1,
                                                                                pacn:       theMove.inactiveColorMoveRecord.pacn
                                                                            })
                                                    });
                        
                                                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                        " btnCheckGameResults.OnSelect(): computer's turn - selected san: " & theMove.inactiveColorMoveRecord.san &
                                                        " pacn: " & theMove.inactiveColorMoveRecord.pacn
                                                    });
                        
                                                    // ready to make the next move in this game
                                                    // Set(gblPF_TMR_MakeNextGameMove, false);Set(gblPF_TMR_MakeNextGameMove, true);Set(gblPF_TMR_MakeNextGameMove, false);
                                                    Set(gblPF_TMR_MakeNextGameMove, false);
                                                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                        " btnCheckCompleteTestResults.OnSelect(): TEST_COMPLETE calling Reset(tmrMakeNextGameMove)"
                                                    });
                                                    Reset(tmrMakeNextGameMove);
                                                    Set(gblPF_TMR_MakeNextGameMove, true)
                                                )
                                            )
                                        )
                                    )
                                )
                            );
                        
                            With(
                                LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                        
                                Set(gblPF_UI_StatusText, theData.uiData.statusText);
                                Set(gblPF_UI_StatusFill, theData.uiData.statusFill);
                                Set(gblPF_UI_DiagnosticText, theData.uiData.diagnosticText);
                                Set(gblPF_UI_DiagnosticFill, theData.uiData.diagnosticFill);
                        
                                If(theData.chessEngineData.moveNumber>5 && Mod(theData.chessEngineData.moveNumber,gblPF_CLEAR_LOG_MOD)=0,
                                    // THEN - let's clear out the log data for performance reasons
                                    comUtilityFunctionsLibrary.fUtilInitData(100)
                                )
                            )
                        )
                    Text: ="Button"
                    Visible: =false
                    X: =100
                    Y: =100
                    ZIndex: =11

                tmrMakeNextGameMove As timer:
                    AutoPause: =false
                    DisplayMode: =DisplayMode.View
                    Duration: =If(radPlayerColor.SelectedText.Value="Neither",3000,500)
                    Height: =27
                    OnTimerEnd: |-
                        =If(Mod(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveNumber,3)=0,
                            Clear(colPF_logs)
                        );
                        
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " tmrMakeNextGameMove.OnTimerEnd(): entered gblPF_TMR_MakeNextGameMove: " & gblPF_TMR_MakeNextGameMove
                        });
                        
                        Set(gblPF_TMR_MakeNextGameMove, false);
                        
                        With(
                            LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                        
                            If(theData.chessEngineData.isGame,
                                // THEN game still going
                                If(theData.chessEngineData.testNumber<0,
                                    // THEN - not a Game Test
                                    With(
                                        LookUp(colPF_MOVE_TREE, nodeDepth=1 && inactiveColorMoveRecord.pacn=theData.chessEngineData.pacn) As theMove,
                        
                                        UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                            uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                        diagnosticText:     "Computer's turn - san: " & theMove.inactiveColorMoveRecord.san &
                                                                            " pacn: " & theMove.inactiveColorMoveRecord.pacn,
                                                        diagnosticFill:     COLOR_GREENish
                                                    })
                                        })
                                    )
                                );
                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: 
                                    "tmrMakeNextGameMove.OnTimerEnd(): calling Select(btnProcessGame)"
                                });
                                Select(btnProcessGame);
                            )
                        );
                        
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: 
                            "tmrMakeNextGameMove.OnTimerEnd(): exiting gblPF_TMR_MakeNextGameMove: " & gblPF_TMR_MakeNextGameMove
                        });
                    OnTimerStart: |-
                        =Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " tmrMakeNextGameMove_CB.OnTimerStart(): entered gblPF_TMR_MakeNextTestMove: " & gblPF_TMR_MakeNextTestMove
                        });
                        
                        
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " tmrMakeNextGameMove_CB.OnTimerStart(): exiting gblPF_TMR_MakeNextTestMove: " & gblPF_TMR_MakeNextTestMove
                        });
                    Size: =10
                    Start: =gblPF_TMR_MakeNextGameMove
                    Width: =98
                    X: =12
                    Y: =471
                    ZIndex: =12

                radPlayerColor As radio:
                    Default: ="White"
                    Height: =43
                    Items: =["White", "Black", "Both", "Neither"]
                    Layout: =Layout.Horizontal
                    RadioSize: =15
                    Size: =10
                    Width: =348
                    X: =25
                    Y: =33
                    ZIndex: =13

            conControlsSharedArea As groupContainer.manualLayoutContainer:
                Height: =50
                Width: =Parent.Width
                ZIndex: =3

                radMode As radio:
                    Default: ="Game"
                    Height: =37
                    Items: =["Game", "Diagnostics"]
                    Layout: =Layout.Horizontal
                    OnSelect: |
                        =If(radMode.SelectedText.Value="Diagnostics",
                            // THEN
                            Set(gblPF_UI_ModeText, "Diagnostic Mode");
                            Set(gblPF_UI_ModeFill, COLOR_YELLOWish),
                        
                            // ELSE
                            Set(gblPF_UI_ModeText, "Game Mode");
                            Set(gblPF_UI_ModeFill, COLOR_GREENish)
                        );
                    RadioSize: =15
                    Size: =10
                    Width: =216
                    X: =220
                    Y: =8
                    ZIndex: =1

            btnProcessGame As button:
                OnSelect: |+
                    =If(Not(gblPF_PAUSE),
                    
                        With(
                            LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                    
                            Set(gblPF_UI_StatusText, theData.uiData.statusText);
                            Set(gblPF_UI_StatusFill, theData.uiData.statusFill);
                            Set(gblPF_UI_DiagnosticText, theData.uiData.diagnosticText);
                            Set(gblPF_UI_DiagnosticFill, theData.uiData.diagnosticFill);
                    
                            With(
                                LookUp(colPF_MOVE_HISTORY, nodeID=theData.chessEngineData.moveHistoryTAILNodeID) As theD0ParentNode,
                    
                    /*
                    UDF_getGamePhaseStr(fen:Text):Text=
                        Switch(true,
                            UDF_getGamePhase(fen)=GAME_PHASE_OPENING,   "OPENING",
                            UDF_getGamePhase(fen)=GAME_PHASE_MIDDLE,    "MIDDLE GAME",
                            "END GAME"
                        );
                     */
                                If(!IsBlank(theD0ParentNode),
                                    Set(gblPF_UI_GamePhase, "OPENING"),
                                    Set(gblPF_UI_GamePhase, "")
                                )
                            )
                        );
                    
                        /* ---------------------------------------------------------------------------------------------------------------------------------------------------------
                        GAME_POST_PLAY
                    
                        - moves 1+
                        - this is where the player, computer, or test has picked the move from D1 nodes
                        - promote D1 node to move tree D0
                        - get rid unused move tree D1 nodes
                        - post move work
                        - if KING or ROOK moved - take away castle rights as appropriate
                        */
                            // TIMER START - GAME_POST_PLAY ================================================================================
                        If(IsBlank(LookUp(colPF_Timers, timerName="btnProcessGame.GAME_POST_PLAY")),
                            Collect(colPF_Timers, {timerName:"btnProcessGame.GAME_POST_PLAY ",startTime:Now(),stopTime:Blank()}),
                            UpdateIf(colPF_Timers, timerName="btnProcessGame.GAME_POST_PLAY", { startTime: Now() })
                        );
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " btnProcessGame.OnSelect(): GAME_POST_PLAY getting started   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv"
                        });
                    
                        With(
                            LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                    
                            If(theData.chessEngineData.isGame=false,
                                // THEN
                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                    " btnProcessGame.OnSelect(): GAME_POST_PLAY test #: " & theData.chessEngineData.testNumber & 
                                    " move #: " & theData.chessEngineData.moveNumber & " testCount: " & theData.chessEngineData.testCount
                                }),
                    
                                // ELSE
                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                    " btnProcessGame.OnSelect(): GAME_POST_PLAY game move #: " & theData.chessEngineData.moveNumber & 
                                    " playerColor: " & theData.chessEngineData.playerColor &
                                    " current move pacn:" & theData.chessEngineData.pacn
                                })
                            );
                    
                            If(theData.chessEngineData.moveNumber>=1,
                                // clear out previous root node of move tree
                                RemoveIf(colPF_MOVE_TREE, nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID);
                    
                                // promote the "selected move" to the root
                                UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                    chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                            moveTreeD0NodeID:       LookUp(colPF_MOVE_TREE, nodeDepth=1 && inactiveColorMoveRecord.pacn=theData.chessEngineData.pacn).nodeID
                                                        })
                                });
                    
                                // the new root has no parent now - make it so - and update it's depth within the move tree
                                UpdateIf(colPF_MOVE_TREE, nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID, {
                                    parentNodeID:   EMPTY_NODE_ID,
                                    nodeDepth:      0
                                });
                    
                                // get rid of any no longer needed nodes - only one is needed
                                RemoveIf(colPF_MOVE_TREE, 
                                    Not(nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID)
                                );
                    
                                With(
                                    LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                    
                                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                        " btnProcessGame.OnSelect(): promoted move to D0 " &
                                        " san: " & theD0ParentNode.inactiveColorMoveRecord.san &
                                        " pacn: " & theD0ParentNode.inactiveColorMoveRecord.pacn
                                    });
                    
                                    // Any KING or ROOK move takes away castle rights
                                    If(UDF_FEN_TO_CASTLE_RIGHTS_ALL_TEXT(theD0ParentNode.postMoveFEN)<>"-",
                                        // THEN - there are some castle rights available - need to take a closer look to see if we need to take some away
                                        If(
                                            UDF_FEN_TO_INACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE && 
                                            (
                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_BOOL(theD0ParentNode.postMoveFEN,WHITE,"K") ||
                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_BOOL(theD0ParentNode.postMoveFEN,WHITE,"Q")
                                            ),
                                            // THEN - check for a WHITE move that takes away a castle right(s)
                                            Switch(true,
                                                IsMatch(theD0ParentNode.inactiveColorMoveRecord.san, "K", MatchOptions.BeginsWith) ||
                                                IsMatch(theD0ParentNode.inactiveColorMoveRecord.san, "O-O", MatchOptions.BeginsWith),
                                                    // got a KING move - take away all WHITE castle rights
                                                    UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                                        postMoveFEN:    UDF_CREATE_FEN(
                                                                            UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),
                                                                            UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN),
                                                                            UDF_CREATE_CASTLE_RIGHTS(
                                                                                "-",
                                                                                "-",
                                                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, BLACK, "k"),
                                                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, BLACK, "q")
                                                                            ),
                                                                            UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN),
                                                                            UDF_FEN_TO_HALFMOVE_COUNT(theD0ParentNode.postMoveFEN),
                                                                            UDF_FEN_TO_FULLMOVE_COUNT(theD0ParentNode.postMoveFEN)
                                                                        )
                                                    }),
                                                IsMatch(theD0ParentNode.inactiveColorMoveRecord.san, "R", MatchOptions.BeginsWith) &&
                                                theD0ParentNode.inactiveColorMoveRecord.sourceSquareName="h1",
                                                    // got a WHITE KS ROOK move - take away the WHITE KS castle
                                                    UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                                        postMoveFEN:    UDF_CREATE_FEN(
                                                                            UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),
                                                                            UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN),
                                                                            UDF_CREATE_CASTLE_RIGHTS(
                                                                                "-",
                                                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, WHITE, "Q"),
                                                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, BLACK, "k"),
                                                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, BLACK, "q")
                    
                                                                            ),
                                                                            UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN),
                                                                            UDF_FEN_TO_HALFMOVE_COUNT(theD0ParentNode.postMoveFEN),
                                                                            UDF_FEN_TO_FULLMOVE_COUNT(theD0ParentNode.postMoveFEN)
                                                                        )
                                                    }),
                                                IsMatch(theD0ParentNode.inactiveColorMoveRecord.san, "R", MatchOptions.BeginsWith) &&
                                                theD0ParentNode.inactiveColorMoveRecord.sourceSquareName="a1",
                                                    // got a WHITE QS ROOK move - take away the WHITE QS castle
                                                    UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                                        postMoveFEN:    UDF_CREATE_FEN(
                                                                            UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),
                                                                            UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN),
                                                                            UDF_CREATE_CASTLE_RIGHTS(
                                                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, WHITE, "K"),
                                                                                "-",
                                                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, BLACK, "k"),
                                                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, BLACK, "q")
                                                                            ),
                                                                            UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN),
                                                                            UDF_FEN_TO_HALFMOVE_COUNT(theD0ParentNode.postMoveFEN),
                                                                            UDF_FEN_TO_FULLMOVE_COUNT(theD0ParentNode.postMoveFEN)
                                                                        )
                                                    })
                                            ),
                    
                                            // ELSE- check for a BLACK move that takes away a castle right(s)
                                            If(
                                                UDF_FEN_TO_INACTIVE_COLOR(theD0ParentNode.postMoveFEN)=BLACK && 
                                                (
                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_BOOL(theD0ParentNode.postMoveFEN,BLACK,"k") ||
                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_BOOL(theD0ParentNode.postMoveFEN,BLACK,"q")
                                                ),
                                                // THEN - check for a BLACK move that takes away a castle right(s)
                                                Switch(true,
                                                    IsMatch(theD0ParentNode.inactiveColorMoveRecord.san, "K", MatchOptions.BeginsWith) ||
                                                    IsMatch(theD0ParentNode.inactiveColorMoveRecord.san, "O-O", MatchOptions.BeginsWith),
                                                        // got a BLACK KING move - take away all BLACK castle rights
                                                        UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                                            postMoveFEN:    UDF_CREATE_FEN(
                                                                                UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),
                                                                                UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN),
                                                                                UDF_CREATE_CASTLE_RIGHTS(
                                                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, WHITE, "K"),
                                                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, WHITE, "Q"),
                                                                                    "-",
                                                                                    "-"
                                                                                ),
                                                                                UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN),
                                                                                UDF_FEN_TO_HALFMOVE_COUNT(theD0ParentNode.postMoveFEN),
                                                                                UDF_FEN_TO_FULLMOVE_COUNT(theD0ParentNode.postMoveFEN)
                                                                            )
                                                        }),
                                                    IsMatch(theD0ParentNode.inactiveColorMoveRecord.san, "R", MatchOptions.BeginsWith) &&
                                                    theD0ParentNode.inactiveColorMoveRecord.sourceSquareName="h8",
                                                        // got a BLACK KS ROOK move - take away the BLACK KS castle
                                                        UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                                            postMoveFEN:    UDF_CREATE_FEN(
                                                                                UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),
                                                                                UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN),
                                                                                UDF_CREATE_CASTLE_RIGHTS(
                                                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, WHITE, "K"),
                                                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, WHITE, "Q"),
                                                                                    "-",
                                                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, BLACK, "q")
                                                                                ),
                                                                                UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN),
                                                                                UDF_FEN_TO_HALFMOVE_COUNT(theD0ParentNode.postMoveFEN),
                                                                                UDF_FEN_TO_FULLMOVE_COUNT(theD0ParentNode.postMoveFEN)
                                                                            )
                                                        }),
                                                    IsMatch(theD0ParentNode.inactiveColorMoveRecord.san, "R", MatchOptions.BeginsWith) &&
                                                    theD0ParentNode.inactiveColorMoveRecord.sourceSquareName="a8",
                                                        // THEN - BLACK QS ROOK move - take away the BLACK QS castle
                                                        UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                                            postMoveFEN:    UDF_CREATE_FEN(
                                                                                UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),
                                                                                UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN),
                                                                                UDF_CREATE_CASTLE_RIGHTS(
                                                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, WHITE, "K"),
                                                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, WHITE, "Q"),
                                                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, BLACK, "k"),
                                                                                    "-"
                                                                                ),
                                                                                UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN),
                                                                                UDF_FEN_TO_HALFMOVE_COUNT(theD0ParentNode.postMoveFEN),
                                                                                UDF_FEN_TO_FULLMOVE_COUNT(theD0ParentNode.postMoveFEN)
                                                                            )
                                                        })
                                                )
                                            )
                                        )
                                    );
                    
                                    // Any ROOK capture takes away castle rights
                                    If(UDF_FEN_TO_CASTLE_RIGHTS_ALL_TEXT(theD0ParentNode.postMoveFEN)<>"-",
                                        // THEN - there are some castle rights available - need to take a closer look to see if we need to take some away
                                        If(
                                            UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE && 
                                            (
                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_BOOL(theD0ParentNode.postMoveFEN,WHITE,"K") ||
                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_BOOL(theD0ParentNode.postMoveFEN,WHITE,"Q")
                                            ),
                                            // THEN - check for a WHITE move that takes away a castle right(s)
                                            Switch(true,
                                                theD0ParentNode.inactiveColorMoveRecord.captureSquareName="h1",
                                                    // got a WHITE KS ROOK captured - take away the WHITE KS castle
                                                    UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                                        postMoveFEN:    UDF_CREATE_FEN(
                                                                            UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),
                                                                            UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN),
                                                                            UDF_CREATE_CASTLE_RIGHTS(
                                                                                "-",
                                                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, WHITE, "Q"),
                                                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, BLACK, "k"),
                                                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, BLACK, "q")
                    
                                                                            ),
                                                                            UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN),
                                                                            UDF_FEN_TO_HALFMOVE_COUNT(theD0ParentNode.postMoveFEN),
                                                                            UDF_FEN_TO_FULLMOVE_COUNT(theD0ParentNode.postMoveFEN)
                                                                        )
                                                    }),
                                                theD0ParentNode.inactiveColorMoveRecord.captureSquareName="a1",
                                                    // got a WHITE QS ROOK move - take away the WHITE QS castle
                                                    UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                                        postMoveFEN:    UDF_CREATE_FEN(
                                                                            UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),
                                                                            UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN),
                                                                            UDF_CREATE_CASTLE_RIGHTS(
                                                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, WHITE, "K"),
                                                                                "-",
                                                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, BLACK, "k"),
                                                                                UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, BLACK, "q")
                                                                            ),
                                                                            UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN),
                                                                            UDF_FEN_TO_HALFMOVE_COUNT(theD0ParentNode.postMoveFEN),
                                                                            UDF_FEN_TO_FULLMOVE_COUNT(theD0ParentNode.postMoveFEN)
                                                                        )
                                                    })
                                            ),
                    
                                            // ELSE- check for a BLACK move that takes away a castle right(s)
                                            If(
                                                UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=BLACK && 
                                                (
                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_BOOL(theD0ParentNode.postMoveFEN,BLACK,"k") ||
                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_BOOL(theD0ParentNode.postMoveFEN,BLACK,"q")
                                                ),
                                                // THEN - check for a BLACK move that takes away a castle right(s)
                                                Switch(true,
                                                    theD0ParentNode.inactiveColorMoveRecord.captureSquareName="h8",
                                                        // got a BLACK KS ROOK move - take away the BLACK KS castle
                                                        UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                                            postMoveFEN:    UDF_CREATE_FEN(
                                                                                UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),
                                                                                UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN),
                                                                                UDF_CREATE_CASTLE_RIGHTS(
                                                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, WHITE, "K"),
                                                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, WHITE, "Q"),
                                                                                    "-",
                                                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, BLACK, "q")
                                                                                ),
                                                                                UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN),
                                                                                UDF_FEN_TO_HALFMOVE_COUNT(theD0ParentNode.postMoveFEN),
                                                                                UDF_FEN_TO_FULLMOVE_COUNT(theD0ParentNode.postMoveFEN)
                                                                            )
                                                        }),
                                                    theD0ParentNode.inactiveColorMoveRecord.captureSquareName="a8",
                                                        // THEN - BLACK QS ROOK move - take away the BLACK QS castle
                                                        UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                                            postMoveFEN:    UDF_CREATE_FEN(
                                                                                UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),
                                                                                UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN),
                                                                                UDF_CREATE_CASTLE_RIGHTS(
                                                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, WHITE, "K"),
                                                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, WHITE, "Q"),
                                                                                    UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_TEXT(theD0ParentNode.postMoveFEN, BLACK, "k"),
                                                                                    "-"
                                                                                ),
                                                                                UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN),
                                                                                UDF_FEN_TO_HALFMOVE_COUNT(theD0ParentNode.postMoveFEN),
                                                                                UDF_FEN_TO_FULLMOVE_COUNT(theD0ParentNode.postMoveFEN)
                                                                            )
                                                        })
                                                )
                                            )
                                        )
                                    )
                                )
                            );
                    
                            With(
                                LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                    
                                With(
                                    LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                    
                                    Set(gblPF_UI_DisplayedBoard, UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN));
                                    Set(gblPF_UI_GameTurn, UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN));
                                    Set(gblPF_UI_MaterialValueOverall,
                                        UDF_calcCentipawnMaterialValue(theD0ParentNode.postMoveFEN,"KQRBNPkqrbnp")/100
                                    );
                                    If(theD0ParentNode.inactiveColorMoveRecord.captureSquareNum<>EMPTY_SQUARE_NUM,
                                        If(theD0ParentNode.inactiveColorMoveRecord.captureSquarePieceColor=WHITE,
                                            Set(gblPF_UI_whiteCapturedPieces, gblPF_UI_whiteCapturedPieces & theD0ParentNode.inactiveColorMoveRecord.captureSquareIcon),
                                            Set(gblPF_UI_blackCapturedPieces, gblPF_UI_blackCapturedPieces & theD0ParentNode.inactiveColorMoveRecord.captureSquareIcon)
                                        )
                                    );
                                    Set(gblPF_UI_DisplayedFEN,
                                        UDF_BOARD_TO_FEN_PIECE_PLACEMENT(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN)) & " " &
                                        If(UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE,"w","b") & " " &
                                        UDF_FEN_TO_CASTLE_RIGHTS_ALL_TEXT(theD0ParentNode.postMoveFEN) & " " &
                                        UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN) & " " &
                                        UDF_FEN_TO_HALFMOVE_COUNT(theD0ParentNode.postMoveFEN) & " " &
                                        UDF_FEN_TO_FULLMOVE_COUNT(theD0ParentNode.postMoveFEN)
                                    )
                                )
                            );
                    
                            // TIMER END - GAME_POST_PLAY ================================================================================
                            UpdateIf(colPF_Timers, timerName="btnProcessGame.GAME_POST_PLAY", { stopTime: Now() });
                            With(
                                LookUp(colPF_Timers, timerName="btnProcessGame.GAME_POST_PLAY") As theTimer,
                    
                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                    " btnProcessGame.OnSelect(): GAME_POST_PLAY " &
                                    Text(DateDiff(theTimer.startTime, theTimer.stopTime, TimeUnit.Milliseconds)/1000) & " seconds"
                                })
                            );
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " btnProcessGame.OnSelect(): GAME_POST_PLAY finished  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                            })
                        );
                    
                        /* -----------------------------------------------------------------------------------------------------------------------------------------------------------
                        GAME_STATUS_PRE_D1
                    
                        - moves 0+
                        - fields that have to be calculated post D0 creation and before D1 moves can be generated
                        - calculate and populate critical "bootstrap" fields for "current" (move tree D0) position
                        - postMoveNumActiveChecks - number of checkers on the active king
                        - postMoveCheckers string of all of the square names that are occupied by a piece who has the active KING in check, the square names are space separated
                        - postMoveActiveKingDangerBoard - mark squares attacked by inactive pieces on a board w/ the active KING removed
                        - postMovePUSHs string of all of the square names that are unoccupied, but a check on the active KING would be blocked if a piece were moved there
                        - postMovePINs_N string of all of the square names that are occupied by a piece either partially PINNED to the active KING and can move in this direction
                        - postMovePINs_NE string of all of the square names that are occupied by a piece either partially PINNED to the active KING and can move in this direction
                        - postMovePINs_E string of all of the square names that are occupied by a piece either partially PINNED to the active KING and can move in this direction
                        - postMovePINs_SE string of all of the square names that are occupied by a piece either partially PINNED to the active KING and can move in this direction
                        - postMovePINs_S string of all of the square names that are occupied by a piece either partially PINNED to the active KING and can move in this direction
                        - postMovePINs_SW string of all of the square names that are occupied by a piece either partially PINNED to the active KING and can move in this direction
                        - postMovePINs_W string of all of the square names that are occupied by a piece either partially PINNED to the active KING and can move in this direction
                        - postMovePINs_NW string of all of the square names that are occupied by a piece either partially PINNED to the active KING and can move in this direction
                        - postMovePINs string of all of the square names that are occupied by a piece either absolutely PINNED or partially PINNED to the active KING
                        - postMovePINDirections all of the directions that have a PIN of some kind, space separated
                        - for each available castle type of the active color - determine if the board currently allows for that particuliar move
                            - num of checks is 0
                            - empty spaces between KING and ROOK
                            - empty spaces are not being attacked
                        */
                    
                        // go through all of the non-active color pieces using each inactive piece as the source, and then see if that piece 
                        // has a move that will allow it to check the active K
                        With (
                            LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                    
                            If(IsBlank(LookUp(colPF_Timers, timerName="btnProcessGame.GAME_STATUS_PRE_D1")),
                                Collect(colPF_Timers, {timerName:"btnProcessGame.GAME_STATUS_PRE_D1",startTime:Now(),stopTime:Blank()}),
                                UpdateIf(colPF_Timers, timerName="btnProcessGame.GAME_STATUS_PRE_D1", { startTime: Now() })
                            );
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " btnProcessGame.OnSelect(): GAME_STATUS_PRE_D1 getting started   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv"
                            });
                    
                            With(
                                LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                    
                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                    " btnProcessGame.OnSelect(): GAME_STATUS_PRE_D1 test #: " & theData.chessEngineData.testNumber & 
                                    " move #: " & theData.chessEngineData.moveNumber & " testCount: " & theData.chessEngineData.testCount
                                })
                            );
                    
                            UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                postMoveNumActiveChecks:        0,
                                postMoveCheckers:               "",
                                postMovePUSHs:                  "",
                                postMoveActiveKingDangerBoard:  EMPTY_BOARD
                            });
                    
                            // get all of the possible moves for each inactive piece that attacks the active king
                            ForAll (
                                Sequence(64,0) As theSqNum,
                    
                                If(
                                    Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value))) && 
                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value) exactin UDF_getICPieceABBR(theD0ParentNode.postMoveFEN, "KQRBNP"),
                                    // THEN - got an inactive piece
                    
                                    // loop through all of the pieces to count number of active CHECKERS
                                    ForAll (
                                        Filter(colPF_LEGAL_MOVES, 
                                            sqNum=theSqNum.Value &&
                                            pieceUpper= // the PAWN is case sensitive since it is uni-directional
                                                If(
                                                    (
                                                        Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value))) &&
                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value) in "P"
                                                    ),
                                                    // THEN
                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value),
                                                    // ELSE
                                                    Upper(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value))
                                                ) &&
                                            eligibleSqNum=UDF_SearchBoardForPiece(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), UDF_getACPieceABBR(theD0ParentNode.postMoveFEN,"K"))
                                        ) As theEligibleMove,
                    
                                        // do not include this move if it is a slider and the overSlider squares are not un-occupied
                                        If(UDF_isPathClear(theD0ParentNode.postMoveFEN, theSqNum.Value, theEligibleMove.theDistance, theEligibleMove.slideOvers),
                                            // THEN - not BLOCKED - add additional filters here
                                            Switch(true,
                                                (
                                                    Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value))) &&
                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value) in "P"
                                                ) && (
                                                    Not(IsBlank(theEligibleMove.theDirection)) &&
                                                    Text(theEligibleMove.theDirection) in "15"
                                                ),
                                                    // PAWN NORTH-SOUTH moves are non-attacking moves - skip over them
                                                    Blank(),
                    
                                                // default - process normally - don't need to update if source square already in checkers list - this happens on pawn promo moves
                                                If(
                                                    Not(
                                                        theEligibleMove.sqName in LookUp(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID).postMoveCheckers
                                                    ),
                                                    // THEN
                                                    UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, 
                                                        {
                                                            postMoveNumActiveChecks: LookUp(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID).postMoveNumActiveChecks + 1,
                                                            postMoveCheckers:           
                                                                TrimEnds(
                                                                    LookUp(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID).postMoveCheckers & " " & theEligibleMove.sqName
                                                                ),
                                                            postMovePUSHs:           
                                                                TrimEnds(
                                                                    LookUp(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID).postMovePUSHs & " " & theEligibleMove.slideOvers
                                                                )
                                                        }
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            );
                    
                            // sort postMoveCheckers if there is more than one CHECK
                            If(LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID).postMoveNumActiveChecks>=2,
                                // THEN
                                UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                    postMoveCheckers:
                                        Concat(Sort(Split(LookUp(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID).postMoveCheckers, " "), Value), Value, " ")
                                })
                            )
                        );
                    
                        With (
                            LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                            // populate the noActiveKingBoard board w/o the king - the no king board will be used as the attacks from 
                            UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                        noActiveKingBoard:  UDF_setBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),EMPTY_FILLER_ABBR,
                                                                                UDF_SearchBoardForPiece(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), UDF_getACPieceABBR(theD0ParentNode.postMoveFEN, "K"))
                                                                            )
                                                    })
                            });
                    
                            // get all of the possible moves for each inactive pieces
                            ForAll (
                                Sequence(64,0) As theSqNum,
                    
                                // for each inactive pieces, mark the target squares in the postMoveActiveKingDangerBoard w/ their piece type
                                If(
                                    Not(IsBlank(UDF_getBitAtSqNum(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.noActiveKingBoard,theSqNum.Value))) &&
                                    UDF_getBitAtSqNum(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.noActiveKingBoard,theSqNum.Value) exactin 
                                        UDF_getICPieceABBR(theD0ParentNode.postMoveFEN,"KQRBNP"),
                    
                                    // THEN - got an inactive piece - loop through all of the moves to mark the attacked squares
                                    ForAll (
                                        Filter(colPF_LEGAL_MOVES, 
                                            sqNum=theSqNum.Value &&
                                            pieceUpper= // the PAWN is case sensitive since it is uni-directional
                                                If(
                                                    (
                                                        Not(IsBlank(UDF_getBitAtSqNum(
                                                            LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.noActiveKingBoard,
                                                            theSqNum.Value
                                                        ))) &&
                                                        UDF_getBitAtSqNum(
                                                            LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.noActiveKingBoard,
                                                            theSqNum.Value
                                                        ) in "P"
                                                    ),
                                                    // THEN - it is a PAWN - leave the case alone
                                                    UDF_getBitAtSqNum(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.noActiveKingBoard,
                                                        theSqNum.Value
                                                    ),
                    
                                                    // ELSE - it is something else - UPPER case it for the query
                                                    Upper(UDF_getBitAtSqNum(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.noActiveKingBoard,
                                                        theSqNum.Value)
                                                    )
                                                ) &&
                                            (
                                                castle="-" ||
                                                castle exactin UDF_FEN_TO_CASTLE_RIGHTS_ALL_TEXT(theD0ParentNode.postMoveFEN)
                                            )
                                        ) As theEligibleMove,
                    
                                        // do not include this move if it is a slider and the overSlider squares are not un-occupied
                                        If(
                                            (
                                                Not(IsBlank(UDF_getBitAtSqNum(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.noActiveKingBoard,theSqNum.Value))) &&
                                                UDF_getBitAtSqNum(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.noActiveKingBoard,theSqNum.Value) exactin 
                                                    UDF_getICPieceABBR(theD0ParentNode.postMoveFEN,"KN") 
                                            ) ||
                                            (
                                                (
                                                    Not(IsBlank(UDF_getBitAtSqNum(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.noActiveKingBoard,theSqNum.Value))) &&
                                                    UDF_getBitAtSqNum(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.noActiveKingBoard,theSqNum.Value) exactin 
                                                        UDF_getICPieceABBR(theD0ParentNode.postMoveFEN,"QRBP") 
                                                ) &&
                                                (
                                                    theEligibleMove.theDistance=1 || // no slide overs - an adjacent square move - process it
                                                    (
                                                        theEligibleMove.theDistance>1 && // check the BLOCKED slide over situation
                                                        !IsMatch(
                                                            Concat(
                                                                ForAll (
                                                                    Split(theEligibleMove.slideOvers, " ") As aSliderOver,
                    
                                                                    If(UDF_getBitAtSqNum(
                                                                        LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.noActiveKingBoard, 
                                                                        UDF_sqNameToSqNum(aSliderOver.Value))<>EMPTY_FILLER_ABBR,
                                                                        "BLOCKED", ""
                                                                    )
                                                                ),
                                                                Value,""
                                                            ),
                                                            "BLOCKED", MatchOptions.Contains
                                                        )
                                                    )
                                                )
                                            ),
                    
                                            // THEN - not BLOCKED - Add any additional filters here
                                            Switch(true,
                                                (
                                                    Not(IsBlank(UDF_getBitAtSqNum(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.noActiveKingBoard,theSqNum.Value))) &&
                                                    UDF_getBitAtSqNum(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.noActiveKingBoard,theSqNum.Value) in "P"
                                                ) &&
                                                Text(theEligibleMove.theDirection) in "15",
                                                    // PAWN NORTH-SOUTH moves are non-attacking moves - skip over them
                                                    Blank(),
                    
                                                // default
                                                UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                                    postMoveActiveKingDangerBoard:  UDF_setBitAtSqNum(
                                                                                        LookUp(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID).postMoveActiveKingDangerBoard,
                                                                                        theEligibleMove.pieceUpper,
                                                                                        theEligibleMove.eligibleSqNum
                                                                                    )
                                                })
                                            )
                                        )
                                    )
                                )
                            )
                        );
                    
                        /*
                            To find all of the current PINNED pieces 
                            - start with the activeColor KING
                            - loop through each direction
                            - move out 1 square at a time and look for the pattern
                            - none or more unoccupied squares, a piece of the active Color, none or more uoccupied squares, a inactive piece slider of proper type
                            -- where the proper type depends upon the direction
                                N, S, E, W -> "QR"
                                NE, SE, SW, NW -> "QB"
                            */
                        With(
                            LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                    
                            UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                postMovePINs_N:                     "",
                                postMovePINs_NE:                    "",
                                postMovePINs_E:                     "",
                                postMovePINs_SE:                    "",
                                postMovePINs_S:                     "",
                                postMovePINs_SW:                    "",
                                postMovePINs_W:                     "",
                                postMovePINs:                       "",
                                postMovePINDirections:              ""
                            });
                    
                            With(
                                {
                                    sqNum: UDF_SearchBoardForPiece(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), UDF_getACPieceABBR(theD0ParentNode.postMoveFEN, "K")) 
                                } As theKingSqNum,
                    
                                ForAll(
                                    Sequence(8,1) As theDir,
                    
                    
                                    UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                        chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                pinneeSqName:       EMPTY_SQUARE_NAME,
                                                                pinnerSqName:       EMPTY_SQUARE_NAME,
                                                                pinnerPatternBroke: false
                                                            })
                                    });
                    
                                    With(
                                        {
                                            eligiblePinners:    If(Text(theDir.Value) in "1357","QR","QB")
                                        } As theEligiblePinPieces,
                    
                                        ForAll(
                                            Sequence(7, 1) As theStep,
                    
                                            With(
                                                // reset on every step in order to try and stay current w/ updates
                                                LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                    
                                                If(
                                                    Not(
                                                        theData.chessEngineData.pinnerPatternBroke ||
                                                        (
                                                            theData.chessEngineData.pinneeSqName<>EMPTY_SQUARE_NAME &&
                                                            theData.chessEngineData.pinnerSqName<>EMPTY_SQUARE_NAME
                                                        )
                                                    ),
                                                    // THEN - not done looking
                                                    With(
                                                        LookUp(
                                                            colPF_LEGAL_MOVES, 
                                                            sqNum=theKingSqNum.sqNum && pieceUpper="Q" && // use a queen here just to get the all directions effect
                                                            eligibleSqNum=theKingSqNum.sqNum+(Index(QUEEN_ONESQUARE_MOVE_TABLE,theDir.Value).Value * theStep.Value)
                                                        ) As theEligibleMove,
                    
                                                        If(Not(IsBlank(theEligibleMove)),
                                                            // THEN - this destination square is on the board
                                                            If(
                                                                UDF_isPieceAC(
                                                                    theD0ParentNode.postMoveFEN,
                                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theEligibleMove.eligibleSqNum)
                                                                ) && theData.chessEngineData.pinneeSqName=EMPTY_SQUARE_NAME && theData.chessEngineData.pinnerSqName=EMPTY_SQUARE_NAME,
                                                                // THEN - found a potential pinnee
                                                                UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                                    chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                                            pinneeSqName:  UDF_sqNameNoPromo(theEligibleMove.eligibleSqName)
                                                                                        })
                                                                }),
                    
                                                                If(
                                                                    Not(UDF_isPieceAC(
                                                                        theD0ParentNode.postMoveFEN,
                                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theEligibleMove.eligibleSqNum)
                                                                    )) && theData.chessEngineData.pinneeSqName<>EMPTY_SQUARE_NAME && theData.chessEngineData.pinnerSqName=EMPTY_SQUARE_NAME
                                                                    && (
                                                                        Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theEligibleMove.eligibleSqNum))) &&
                                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theEligibleMove.eligibleSqNum) in theEligiblePinPieces.eligiblePinners
                                                                    ),
                    
                                                                    // THEN - found a pinner
                                                                    UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                                        chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                                                pinnerSqName:  UDF_sqNameNoPromo(theEligibleMove.eligibleSqName)
                                                                                            })
                                                                    });
                    
                                                                    UpdateIf(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID, 
                                                                        Switch(true,
                                                                            theDir.Value=1, { postMovePINs_N:     theData.chessEngineData.pinneeSqName },
                                                                            theDir.Value=2, { postMovePINs_NE:    theData.chessEngineData.pinneeSqName },
                                                                            theDir.Value=3, { postMovePINs_E:     theData.chessEngineData.pinneeSqName },
                                                                            theDir.Value=4, { postMovePINs_SE:    theData.chessEngineData.pinneeSqName },
                                                                            theDir.Value=5, { postMovePINs_S:     theData.chessEngineData.pinneeSqName },
                                                                            theDir.Value=6, { postMovePINs_SW:    theData.chessEngineData.pinneeSqName },
                                                                            theDir.Value=7, { postMovePINs_W:     theData.chessEngineData.pinneeSqName },
                                                                            theDir.Value=8, { postMovePINs_NW:    theData.chessEngineData.pinneeSqName }
                                                                        )
                                                                    );
                    
                                                                    UpdateIf(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID, 
                                                                        {
                                                                            postMovePINs: TrimEnds(
                                                                                LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID).postMovePINs & " " & theData.chessEngineData.pinneeSqName
                                                                            ),
                                                                            postMovePINDirections: TrimEnds(
                                                                                LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID).postMovePINDirections & " " & 
                                                                                    theDir.Value
                                                                            )
                                                                        }
                                                                    ),
                    
                                                                    If(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theEligibleMove.eligibleSqNum)<>EMPTY_FILLER_ABBR,
                                                                        // THEN - pattern not met
                                                                        UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                                            chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                                                    pinnerPatternBroke:  true
                                                                                                })
                                                                        })
                                                                    )
                                                                )
                                                            ),
                    
                                                            // ELSE - off the board - done looking in this direction
                                                            UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                                chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                                        pinnerPatternBroke:  true
                                                                                    })
                                                            })
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            )
                        );
                    
                        // TIMER END - GAME_STATUS_PRE_D1 ================================================================================
                        UpdateIf(colPF_Timers, timerName="btnProcessGame.GAME_STATUS_PRE_D1", { stopTime: Now() });
                        With(
                            LookUp(colPF_Timers, timerName="btnProcessGame.GAME_STATUS_PRE_D1") As theTimer,
                    
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " btnProcessGame.OnSelect(): GAME_STATUS_PRE_D1 " &
                                Text(DateDiff(theTimer.startTime, theTimer.stopTime, TimeUnit.Milliseconds)/1000) & " seconds"
                            })
                        );
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " btnProcessGame.OnSelect():  GAME_STATUS_PRE_D1  finished   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                        });
                    
                    
                        /* -----------------------------------------------------------------------------------------------------------------------------------------------------------
                        GAME_NODES
                    
                        - moves 0+
                        - NOTE: the move tree D0 postMove data is "current" (move tree D0) position
                        - this state creates all of the legal D1 nodes
                        */
                        // THEN - TIMER START - GAME_NODES ================================================================================
                        If(IsBlank(LookUp(colPF_Timers, timerName="btnProcessGame.GAME_NODES")),
                            Collect(colPF_Timers, {timerName:"btnProcessGame.GAME_NODES",startTime:Now(),stopTime:Blank()}),
                            UpdateIf(colPF_Timers, timerName="btnProcessGame.GAME_NODES", { startTime: Now() })
                        );
                    
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " btnProcessGame.OnSelect(): GAME_NODES getting started    vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv"
                        });
                    
                        With(
                            LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                    
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " btnProcessGame.OnSelect(): GAME_NODES test #: " & theData.chessEngineData.testNumber & 
                                " move #: " & theData.chessEngineData.moveNumber & " testCount: " & theData.chessEngineData.testCount
                            })
                        );
                    
                        With(
                            LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                    
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " PREMOVE FEN: " & LF & theD0ParentNode.preMoveFEN
                            });
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " PREMOVE BOARD: " & LF & UDF_FEN_TO_BOARD(theD0ParentNode.preMoveFEN)
                            });
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " theD0ParentNode.postMoveActiveKingDangerBoard: " & LF & theD0ParentNode.postMoveActiveKingDangerBoard
                            });
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " POSTMOVE FEN: " & LF & theD0ParentNode.postMoveFEN
                            });
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " POSTMOVE BOARD: " & LF & UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN)
                            });
                    
                            // get all of the possible moves for each active piece 
                            ForAll (
                                Sequence(64,0) As theSqNum,
                    
                                If(
                                    Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value))) &&
                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value) exactin UDF_getACPieceABBR(theD0ParentNode.postMoveFEN,"KQRBNP"),
                                    // THEN
                                    ForAll (
                                        SortByColumns(Filter(colPF_LEGAL_MOVES, 
                                            sqNum=theSqNum.Value &&
                                            pieceUpper= // the PAWN is case sensitive since it is uni-directional
                                                If(
                                                    (
                                                        Not(IsBlank(UDF_getBitAtSqNum(
                                                            UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),
                                                            theSqNum.Value
                                                        ) in "P")) &&
                                                        UDF_getBitAtSqNum(
                                                            UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),
                                                            theSqNum.Value
                                                        ) in "P"
                                                    ),
                                                    // THEN
                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theSqNum.Value),
                    
                                                    // ELSE
                                                    Upper(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theSqNum.Value))
                                                )
                                        ), "pieceUpper", SortOrder.Ascending, "eligibleSqName", SortOrder.Ascending) As theEligibleMove,
                    
                                        // do not include this move if it is a slider and the overSlider squares are not un-occupied
                                        If(UDF_isPathClear(theD0ParentNode.postMoveFEN, theSqNum.Value, theEligibleMove.theDistance, theEligibleMove.slideOvers),
                                            // THEN - either not a slider or is a not BLOCKED slider
                                            Switch(true,
                                                // is move already in tree ?
                                                CountRows(Filter(colPF_MOVE_TREE, 
                                                    nodeDepth=1 && 
                                                    inactiveColorMoveRecord.pacn=UDF_sqNumToSqName(theSqNum.Value) & theEligibleMove.eligibleSqName
                                                ))>=1,
                                                    // FILTERED - move already in tree
                                                    Blank(),
                    
                                                // can't attack a piece of your own color // filter out moves to same color
                                                UDF_PieceToColor(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value))=UDF_PieceToColor(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theEligibleMove.eligibleSqNum)), 
                                                    // FILTERED - attacking same color
                                                    Blank(),
                    
                                                // PAWN cannot move forward to an occupied square
                                                (
                                                    Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theEligibleMove.sqNum))) &&
                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theEligibleMove.sqNum) in "P"
                                                ) && 
                                                Text(theEligibleMove.theDirection) in "15" &&
                                                UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theEligibleMove.eligibleSqNum)<>EMPTY_FILLER_ABBR,
                                                    // FILTERED - PAWN can not move forward to an occupied square
                                                    Blank(),
                    
                                                // PAWN cannot move diagonally to an unoccupied square unless the source square is the en passant square
                                                (
                                                    Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theEligibleMove.sqNum))) &&
                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theEligibleMove.sqNum) in "P"
                                                ) && 
                                                Text(theEligibleMove.theDirection) in "2468" &&
                                                (
                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theEligibleMove.eligibleSqNum)=EMPTY_FILLER_ABBR &&
                                                    UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN)<>theEligibleMove.eligibleSqName
                                                ),
                                                    // FILTERED - PAWN cannot move diagonally to an unoccupied square unless the source square is the en passant square
                                                    Blank(),
                    
                                                // KING cannot move to an attacked square
                                                (
                                                    Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theEligibleMove.sqNum))) &&
                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theEligibleMove.sqNum) in "K"
                                                ) && 
                                                Not(IsBlank(UDF_getBitAtSqNum(theD0ParentNode.postMoveActiveKingDangerBoard,theEligibleMove.eligibleSqNum))) &&
                                                (
                                                    Not(IsBlank(UDF_getBitAtSqNum(theD0ParentNode.postMoveActiveKingDangerBoard,theEligibleMove.eligibleSqNum))) &&
                                                    UDF_getBitAtSqNum(theD0ParentNode.postMoveActiveKingDangerBoard,theEligibleMove.eligibleSqNum) in "KQRBNP"
                                                ),
                                                    // FILTERED - KING cannot move to an attacked square
                                                    Blank(),
                    
                                                // PINNED pieces can only move if they are sliders
                                                theEligibleMove.sqName in theD0ParentNode.postMovePINs &&
                                                (
                                                    Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum))) &&
                                                    Not(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum) in "QRBP")
                                                ),
                                                    // FILTERED - PINNED pieces can only move if they are sliders
                                                    Blank(),
                    
                                                // PINNED pieces can only move the direction of the PIN or the Active King
                                                theEligibleMove.sqName in theD0ParentNode.postMovePINs && // is this a PINNED piece
                                                If(theEligibleMove.sqName in 
                                                    Switch(true,
                                                        theEligibleMove.theDirection=1 || theEligibleMove.theDirection=5,
                                                            theD0ParentNode.postMovePINs_N & " " & theD0ParentNode.postMovePINs_S,
                                                        theEligibleMove.theDirection=2 || theEligibleMove.theDirection=6,
                                                            theD0ParentNode.postMovePINs_NE & " " & theD0ParentNode.postMovePINs_SW,
                                                        theEligibleMove.theDirection=3 || theEligibleMove.theDirection=7,
                                                            theD0ParentNode.postMovePINs_E & " " & theD0ParentNode.postMovePINs_W,
                                                        theEligibleMove.theDirection=4 || theEligibleMove.theDirection=8,
                                                            theD0ParentNode.postMovePINs_SE & " " & theD0ParentNode.postMovePINs_NW,
                                                        " "
                                                    ),false,true
                                                ),
                                                    // FILTERED - PINNED pieces can only move the direction of the PIN or the Active King
                                                    Blank(),
                    
                                                
                                                // is this a WHITE KS castle move ? if so let's check the conditions
                                                (
                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value) exactin "K" &&
                                                    Concatenate(theEligibleMove.sqName,theEligibleMove.eligibleSqName)="e1g1" &&
                                                    UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE
                                                ) && 
                                                (
                                                    Not(
                                                        // All of these things must be true in order to castle
                                                        UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_BOOL(
                                                            theD0ParentNode.postMoveFEN, 
                                                            UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN), 
                                                            "K"
                                                        ) &&
                                                        theD0ParentNode.postMoveNumActiveChecks=0 &&
                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),61)=EMPTY_FILLER_ABBR &&
                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),62)=EMPTY_FILLER_ABBR &&
                                                        UDF_getBitAtSqNum(theD0ParentNode.postMoveActiveKingDangerBoard, 61)=EMPTY_FILLER_ABBR &&
                                                        UDF_getBitAtSqNum(theD0ParentNode.postMoveActiveKingDangerBoard, 62)=EMPTY_FILLER_ABBR
                                                    )
                                                ), 
                                                    // FILTERED - non-qualified WHITE KS castle
                                                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                        " btnProcessGame.OnSelect(): FILTERED - non-qualified WHITE KS castle " &
                                                        " pacn: " & theEligibleMove.sqName & theEligibleMove.eligibleSqName
                                                    });
                                                    Blank(),
                    
                                                // is this a WHITE QS castle move ? if so let's check the conditions
                                                (
                                                    (
                                                        Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value))) &&
                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value) exactin "K"
                                                    ) &&
                                                    Concatenate(theEligibleMove.sqName,theEligibleMove.eligibleSqName)="e1c1" &&
                                                    UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE
                                                ) && 
                                                (
                                                    Not(
                                                        // All of these things must be true in order to castle
                                                        UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_BOOL(
                                                            theD0ParentNode.postMoveFEN, 
                                                            UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN), 
                                                            "Q"
                                                        ) &&
                                                        theD0ParentNode.postMoveNumActiveChecks=0 &&
                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),57)=EMPTY_FILLER_ABBR &&
                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),58)=EMPTY_FILLER_ABBR &&
                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),59)=EMPTY_FILLER_ABBR &&
                                                        UDF_getBitAtSqNum(theD0ParentNode.postMoveActiveKingDangerBoard, 58)=EMPTY_FILLER_ABBR &&
                                                        UDF_getBitAtSqNum(theD0ParentNode.postMoveActiveKingDangerBoard, 59)=EMPTY_FILLER_ABBR
                                                    )
                                                ), 
                                                    // FILTERED - non-qualified WHITE QS castle
                                                    Blank(),
                    
                                                // is this a BLACK KS castle move ? if so let's check the conditions
                                                (
                                                    (
                                                        Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value))) &&
                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value) exactin "k"
                                                    ) &&
                                                    Concatenate(theEligibleMove.sqName,theEligibleMove.eligibleSqName)="e8g8" &&
                                                    UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=BLACK
                                                ) && 
                                                (
                                                    Not(
                                                        // All of these things must be true in order to castle
                                                        UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_BOOL(
                                                            theD0ParentNode.postMoveFEN, 
                                                            UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN), 
                                                            "k"
                                                        ) &&
                                                        theD0ParentNode.postMoveNumActiveChecks=0 &&
                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),5)=EMPTY_FILLER_ABBR &&
                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),6)=EMPTY_FILLER_ABBR &&
                                                        UDF_getBitAtSqNum(theD0ParentNode.postMoveActiveKingDangerBoard, 5)=EMPTY_FILLER_ABBR &&
                                                        UDF_getBitAtSqNum(theD0ParentNode.postMoveActiveKingDangerBoard, 6)=EMPTY_FILLER_ABBR
                                                    )
                                                ), 
                                                    // FILTERED - non-qualified BLACK KS castle
                                                    Blank(),
                    
                                                // is this a BLACK QS castle move ? if so let's check the conditions
                                                (
                                                    (
                                                        Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value))) &&
                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value) exactin "k"
                                                    ) &&
                                                    Concatenate(theEligibleMove.sqName,theEligibleMove.eligibleSqName)="e8c8" &&
                                                    UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=BLACK
                                                ) && 
                                                (
                                                    Not(
                                                        // All of these things must be true in order to castle
                                                        UDF_FEN_TO_CASTLE_RIGHTS_SPECIFIC_BOOL(
                                                            theD0ParentNode.postMoveFEN, 
                                                            UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN), 
                                                            "q"
                                                        ) &&
                                                        theD0ParentNode.postMoveNumActiveChecks=0 &&
                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),1)=EMPTY_FILLER_ABBR &&
                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),2)=EMPTY_FILLER_ABBR &&
                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),3)=EMPTY_FILLER_ABBR &&
                                                        UDF_getBitAtSqNum(theD0ParentNode.postMoveActiveKingDangerBoard, 2)=EMPTY_FILLER_ABBR &&
                                                        UDF_getBitAtSqNum(theD0ParentNode.postMoveActiveKingDangerBoard, 3)=EMPTY_FILLER_ABBR
                                                    )
                                                ), 
                                                    // FILTERED - non-qualified BLACK QS castle
                                                    Blank(),
                    
                                                // looking for a move that moves the king || captures the checker || pushes in the way of the checker
                                                (theD0ParentNode.postMoveNumActiveChecks=1) && 
                                                Not(
                                                    (
                                                        Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value))) &&
                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value) in "K"
                                                    ) || (
                                                        UDF_sqNameNoPromo(theEligibleMove.eligibleSqName)=theD0ParentNode.postMoveCheckers ||
                                                        ( // tricky one - have to consider the en passant move capturing the pawn who is placing us in check
                                                            // are we a PAWN ?
                                                            UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value)=
                                                                If(UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE,"P","p") &&
                                                            // are we moving to the en passant square ?
                                                            UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN)=UDF_sqNameNoPromo(theEligibleMove.eligibleSqName) &&
                                                            // is the en passant captured PAWN (i.e., the pawn next to our starting position) the checker ?
                                                            UDF_sqNumToSqName(UDF_getEPCaptureSqNum(theD0ParentNode.postMoveFEN))=theD0ParentNode.postMoveCheckers
                                                        )
                                                    ) ||
                                                    (
                                                        Not(IsBlank(theD0ParentNode.postMovePUSHs)) &&
                                                        UDF_sqNameNoPromo(theEligibleMove.eligibleSqName) in theD0ParentNode.postMovePUSHs
                                                    )
                                                ), 
                                                    // FILTERED - CHECKERS = 1 - has to be a king move || captures the checker || pushes in the way of the checker
                                                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                        " FILTERED - CHECKERS = 1 - has to be a king move || captures the checker || pushes in the way of the checker" &
                                                        " checkers: " & theD0ParentNode.postMoveCheckers &
                                                        " sourceSqN: " & theEligibleMove.sqName & "(" & theEligibleMove.eligibleSqNum & ")" &
                                                        " targetSqN: " & theEligibleMove.eligibleSqName & "(" & theEligibleMove.eligibleSqNum & ")"
                                                    });
                    
                                                    If(UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN)<>"-",
                                                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                            " ep: " & UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN) & 
                                                                "(" & UDF_sqNameToSqNum(UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN)) & ")" &
                                                            " ep capture: " &
                                                                UDF_sqNumToSqName(UDF_getEPCaptureSqNum(theD0ParentNode.postMoveFEN)) & 
                                                                "(" & UDF_getEPCaptureSqNum(theD0ParentNode.postMoveFEN) & ")"
                                                        })
                                                    );
                                                    Blank(),
                    
                                                // looking for a move that moves the king
                                                (theD0ParentNode.postMoveNumActiveChecks>=2) &&
                                                (
                                                    Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theEligibleMove.sqNum))) &&
                                                    Not(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theEligibleMove.sqNum) in "K")
                                                ),
                                                    // FILTERED - CHECKERS >= 2 - has to be a king move
                                                    Blank(),
                    
                                                theEligibleMove.castle exactin "KQ" &&
                                                Not(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value) exactin "K"),
                                                    // FILTERED - an INVALID WHITE CASTLE
                                                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                        " btnProcessGame.OnSelect(): FILTERED - an INVALID WHITE CASTLE " &
                                                        " pacn: " & theEligibleMove.sqName & theEligibleMove.eligibleSqName
                                                    });
                                                    Blank(),
                    
                                                theEligibleMove.castle exactin "kq" &&
                                                Not(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),theSqNum.Value) exactin "k"),
                                                    // FILTERED - an INVALID BLACK CASTLE
                                                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                        " btnProcessGame.OnSelect(): FILTERED - an INVALID BLACK CASTLE " &
                                                        " pacn: " & theEligibleMove.sqName & theEligibleMove.eligibleSqName
                                                    });
                                                    Blank(),
                    
                                                // default 
                                                UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                    chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                            newNodeID:       Max(colPF_MOVE_TREE, nodeID) + 1
                                                                        })
                                                });
                    
                                                Patch(colPF_MOVE_TREE, Defaults(colPF_MOVE_TREE), { // adds a new record to colPF_MOVE_TREE 
                                                    nodeID:                 	LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.newNodeID,
                                                    parentNodeID:           	theD0ParentNode.nodeID,
                                                    nodeDepth:					1,
                                                    preMoveFEN:             	theD0ParentNode.postMoveFEN,
                                                    inactiveColorMoveRecord:    
                                                        // Patch(theD0ParentNode.inactiveColorMoveRecord,  {  
                                                        Patch(MOVE_RECORD_PF,  {
                                                            san:
                                                                Switch(true,
                                                                    (
                                                                        Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum))) &&
                                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum) in "K"
                                                                    ) &&
                                                                    (
                                                                        Concatenate(theEligibleMove.sqName,theEligibleMove.eligibleSqName)="e1g1" ||
                                                                        Concatenate(theEligibleMove.sqName,theEligibleMove.eligibleSqName)="e8g8"
                                                                    ),
                                                                        "O-O",
                    
                                                                    (
                                                                        Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum))) &&
                                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum) in "K"
                                                                    ) &&
                                                                    (
                                                                        theEligibleMove.sqName & UDF_sqNameNoPromo(theEligibleMove.eligibleSqName)="e1c1" ||
                                                                        theEligibleMove.sqName & UDF_sqNameNoPromo(theEligibleMove.eligibleSqName)="e8c8"
                                                                    ),
                                                                        "O-O-O",
                    
                                                                    // default - normal SAN processing
                                                                    If(theEligibleMove.pieceUpper in "P",
                                                                        If(UDF_getBitAtSqNum(
                                                                            UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), 
                                                                            theEligibleMove.eligibleSqNum)=EMPTY_FILLER_ABBR,
                                                                            "",
                                                                            UDF_getFileNameFromSqName(theEligibleMove.sqName)
                                                                        ),
                                                                        theEligibleMove.pieceUpper
                                                                    ) & 
                                                                    If(UDF_getBitAtSqNum(
                                                                        UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), 
                                                                        theEligibleMove.eligibleSqNum)=EMPTY_FILLER_ABBR,
                                                                        // THEN
                                                                        "",
                    
                                                                        If( // put in an x for a capture - unless the target is a KING
                                                                            UDF_getBitAtSqNum(
                                                                                UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), 
                                                                                theEligibleMove.eligibleSqNum
                                                                            ) in "K",
                                                                            // THEN
                                                                            "",
                    
                                                                            // ELSE
                                                                            "x"
                                                                        )
                                                                    ) &
                                                                    UDF_sqNumToSqName(theEligibleMove.eligibleSqNum)
                                                                ),
                                                            pacn:               UDF_createPACN(theEligibleMove.sqName, theEligibleMove.eligibleSqName),
                                                            sourceSquareNum:    theSqNum.Value, 
                                                            sourceSquareName:   UDF_sqNumToSqName(theSqNum.Value),
                                                            sourceSquareOccupier:   
                                                                If(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theSqNum.Value)=EMPTY_FILLER_ABBR,
                                                                    EMPTY_ABBR, 
                                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theSqNum.Value)
                                                                ),
                                                            sourceSquarePieceColor: UDF_PieceToColor(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theSqNum.Value)),
                                                            sourceSquareIcon:       UDF_PieceToIcon(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theSqNum.Value)),
                                                            // the target square data is the square data of where the moving piece will end up, it is the data prior to the move
                                                            // the target square may or may not be occupied prior to the move
                                                            targetSquareNum:        theEligibleMove.eligibleSqNum,
                                                            targetSquareName:       UDF_sqNameNoPromo(theEligibleMove.eligibleSqName), // avoid the promo code
                                                            targetSquareOccupier:   
                                                                If(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum)=EMPTY_FILLER_ABBR,
                                                                    EMPTY_ABBR,
                                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum)
                                                                ),
                                                            targetSquarePieceColor: UDF_PieceToColor(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum)),
                                                            targetSquareIcon:       UDF_PieceToIcon(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum)),
                                                            // the capture square data is the square data of the square containing the piece that is captured during the move, 
                                                            //      it is the square data prior to the move
                                                            // the capture square data will be "empty" if there is no capture, in non-en Passant captures the capture data is the 
                                                            // same as the target square data,
                                                            // in an en passant move the data will be of square where the pawn is captured
                                                            captureSquareNum:
                                                                Switch(true,
                                                                    (
                                                                        Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum))) &&
                                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum) in "P"
                                                                    ) &&
                                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum)=EMPTY_FILLER_ABBR &&
                                                                    UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN)<>"-" &&
                                                                    Text(theEligibleMove.theDirection) in "2468",
                                                                        If(Text(theEligibleMove.theDirection) in "28",
                                                                            UDF_getSqNumRelativeToSqNum(theEligibleMove.eligibleSqNum,0,-1),
                                                                            UDF_getSqNumRelativeToSqNum(theEligibleMove.eligibleSqNum,0,1)
                                                                        ),
                    
                                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum)<>EMPTY_FILLER_ABBR,
                                                                        theEligibleMove.eligibleSqNum,
                    
                                                                    // default
                                                                    EMPTY_SQUARE_NUM
                                                                ),
                                                            captureSquareName:
                                                                Switch(true,
                                                                    (
                                                                        Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum))) &&
                                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum) in "P"
                                                                    ) &&
                                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum)=EMPTY_FILLER_ABBR &&
                                                                    UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN)<>"-" &&
                                                                    Text(theEligibleMove.theDirection) in "2468",
                                                                        If(Text(theEligibleMove.theDirection) in "28",
                                                                            UDF_sqNumToSqName(UDF_getSqNumRelativeToSqNum(theEligibleMove.eligibleSqNum,0,-1)),
                                                                            UDF_sqNumToSqName(UDF_getSqNumRelativeToSqNum(theEligibleMove.eligibleSqNum,0,1))
                                                                        ),
                    
                                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum)<>EMPTY_FILLER_ABBR,
                                                                        UDF_sqNameNoPromo(theEligibleMove.eligibleSqName),
                                                                        
                                                                    // default
                                                                    EMPTY_SQUARE_NAME
                                                                ),
                                                            captureSquareOccupier:
                                                                Switch(true,
                                                                    (
                                                                        Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum))) &&
                                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum) in "P"
                                                                    ) &&
                                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum)=EMPTY_FILLER_ABBR &&
                                                                    UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN)<>"-" &&
                                                                    Text(theEligibleMove.theDirection) in "2468",
                                                                        UDF_getBitAtSqNum(
                                                                            UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), 
                                                                            If(Text(theEligibleMove.theDirection) in "28",
                                                                                UDF_getSqNumRelativeToSqNum(theEligibleMove.eligibleSqNum,0,-1),
                                                                                UDF_getSqNumRelativeToSqNum(theEligibleMove.eligibleSqNum,0,1)
                                                                            )
                                                                        ),
                    
                                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum)<>EMPTY_FILLER_ABBR,
                                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum),
                    
                                                                    // default
                                                                    EMPTY_ABBR
                                                                ),
                                                            captureSquarePieceColor:
                                                                Switch(true,
                                                                    (
                                                                        Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum))) &&
                                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum) in "P"
                                                                    ) &&
                                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum)=EMPTY_FILLER_ABBR &&
                                                                    UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN)<>"-" &&
                                                                    Text(theEligibleMove.theDirection) in "2468",
                                                                        UDF_PieceToColor(
                                                                            UDF_getBitAtSqNum(
                                                                                UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), 
                                                                                If(Text(theEligibleMove.theDirection) in "28",
                                                                                    UDF_getSqNumRelativeToSqNum(theEligibleMove.eligibleSqNum,0,-1),
                                                                                    UDF_getSqNumRelativeToSqNum(theEligibleMove.eligibleSqNum,0,1)
                                                                                )
                                                                            )
                                                                        ),
                    
                                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum)<>EMPTY_FILLER_ABBR,
                                                                        UDF_PieceToColor(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum)),
                    
                                                                    // default
                                                                    NO_COLOR
                                                                ),
                                                            captureSquareIcon:
                                                                Switch(true,
                                                                    (
                                                                        Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum))) &&
                                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum) in "P"
                                                                    ) &&
                                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum)=EMPTY_FILLER_ABBR &&
                                                                    UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN)<>"-" &&
                                                                    Text(theEligibleMove.theDirection) in "2468",
                                                                        UDF_PieceToIcon(
                                                                            UDF_getBitAtSqNum(
                                                                                UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), 
                                                                                If(Text(theEligibleMove.theDirection) in "28",
                                                                                    UDF_getSqNumRelativeToSqNum(theEligibleMove.eligibleSqNum,0,-1),
                                                                                    UDF_getSqNumRelativeToSqNum(theEligibleMove.eligibleSqNum,0,1)
                                                                                )
                                                                            )
                                                                        ),
                    
                                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum)<>EMPTY_FILLER_ABBR,
                                                                        UDF_PieceToIcon(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum)),
                    
                                                                    // default
                                                                    EMPTY_ICON
                                                                ),
                                                            promoteTo:  Upper(UDF_getPromo(theEligibleMove.eligibleSqName))
                                                        }),
                                                    postMoveNumActiveChecks:	0
                                                });
                    
                                                With ( 
                                                    LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,      
                    
                                                    With (  // if a castle do the 2nd half of the move - the ROOK part
                                                        LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.newNodeID) As theCurrentNode,
                    
                                                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                            " GAME_NODES IN PROCESS of CREATING MT nodeID: " & theCurrentNode.nodeID & 
                                                            " parentNodeID: " & theCurrentNode.parentNodeID &
                                                            " nodeDepth: " & theCurrentNode.nodeDepth &
                                                            " preMoveFEN: " & theCurrentNode.preMoveFEN
                                                        });
                    
                                                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                            " san: " & theCurrentNode.inactiveColorMoveRecord.san &
                                                            " pacn: " & theCurrentNode.inactiveColorMoveRecord.pacn & " vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv"
                                                        })
                                                    )
                                                );
                    
                                                UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                    chessEngineData:
                                                        Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                            tmpBoard:
                                                                // create board to reflect the move - THE MOVE IS MADE HERE
                                                                Switch(true, // for en passant moves need to clear out the en passant square
                                                                    (
                                                                        Not(IsBlank(UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum))) &&
                                                                        UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.sqNum) in "P"
                                                                    ) &&
                                                                    UDF_getBitAtSqNum(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), theEligibleMove.eligibleSqNum)=EMPTY_FILLER_ABBR &&
                                                                    UDF_FEN_TO_ENPASSANT_SQNAME(theD0ParentNode.postMoveFEN)<>"-" &&
                                                                    Text(theEligibleMove.theDirection) in "2468",
                                                                        UDF_setBitAtSqNum(
                                                                            UDF_makeMovePACN(
                                                                                UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN),
                                                                                UDF_createPACN(theEligibleMove.sqName, theEligibleMove.eligibleSqName)
                                                                            ),
                                                                            EMPTY_FILLER_ABBR,
                                                                            If(Text(theEligibleMove.theDirection) in "28",
                                                                                UDF_getSqNumRelativeToSqNum(theEligibleMove.eligibleSqNum,0,-1),
                                                                                UDF_getSqNumRelativeToSqNum(theEligibleMove.eligibleSqNum,0,1)
                                                                            )
                                                                        ),
                    
                                                                    // default
                                                                    UDF_makeMovePACN(UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN), UDF_createPACN(theEligibleMove.sqName, theEligibleMove.eligibleSqName))
                                                                )
                                                        })
                                                });
                    
                                                With ( 
                                                    LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,      
                    
                                                    With (  // if a castle do the 2nd half of the move - the ROOK part
                                                        LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.newNodeID) As theCurrentNode,
                    
                                                        Switch(true,
                                                            IsMatch(theCurrentNode.inactiveColorMoveRecord.san, "O-O", MatchOptions.Complete) &&
                                                            UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE,
                                                                // WHITE KS CASTLE
                                                                UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                                    chessEngineData:    Patch(theData.chessEngineData, {
                                                                                            tmpBoard: UDF_makeMovePACN(theData.chessEngineData.tmpBoard, "h1f1")
                                                                                        })
                                                                }),
                    
                                                            IsMatch(theCurrentNode.inactiveColorMoveRecord.san, "O-O", MatchOptions.Complete) &&
                                                            UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=BLACK,
                                                                // BLACK KS CASTLE
                                                                UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                                    chessEngineData:    Patch(theData.chessEngineData, {
                                                                                            tmpBoard: UDF_makeMovePACN(theData.chessEngineData.tmpBoard, "h8f8")
                                                                                        })
                                                                }),
                    
                                                            IsMatch(theCurrentNode.inactiveColorMoveRecord.san, "O-O-O", MatchOptions.Complete) &&
                                                            UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE,
                                                                // WHITE QS CASTLE
                                                                UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                                    chessEngineData:    Patch(theData.chessEngineData, {
                                                                                            tmpBoard: UDF_makeMovePACN(theData.chessEngineData.tmpBoard, "a1d1")
                                                                                        })
                                                                }),
                    
                                                            IsMatch(theCurrentNode.inactiveColorMoveRecord.san, "O-O-O", MatchOptions.Complete) &&
                                                            UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=BLACK,
                                                                // BLACK QS CASTLE
                                                                UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                                    chessEngineData:    Patch(theData.chessEngineData, {
                                                                                            tmpBoard: UDF_makeMovePACN(theData.chessEngineData.tmpBoard, "a8d8")
                                                                                        })
                                                                })
                                                        )
                                                    )
                                                );
                    
                                                With ( 
                                                    LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,    
                    
                                                    // update this move's FEN based upon all of the current data of this move
                                                    With (
                                                        LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.newNodeID) As theCurrentNode,
                    
                                                        UpdateIf(colPF_MOVE_TREE, nodeID=theCurrentNode.nodeID, {
                                                            postMoveFEN:    
                                                                UDF_CREATE_FEN(
                                                                    theData.chessEngineData.tmpBoard,
                                                                    UDF_FEN_TO_INACTIVE_COLOR(theCurrentNode.preMoveFEN),
                                                                    UDF_FEN_TO_CASTLE_RIGHTS_ALL_TEXT(theCurrentNode.preMoveFEN),
                    
                                                                    // a ton of logic to determine if this is an en passant setting move
                                                                    Switch(true,
                                                                        UDF_FEN_TO_INACTIVE_COLOR(theCurrentNode.preMoveFEN)=BLACK &&
                                                                        (
                                                                            Not(IsBlank(theCurrentNode.inactiveColorMoveRecord.sourceSquareOccupier)) &&
                                                                            theCurrentNode.inactiveColorMoveRecord.sourceSquareOccupier exactin "P"
                                                                        ) && // PAWN move
                                                                        UDF_getRankFromSqNum(theCurrentNode.inactiveColorMoveRecord.sourceSquareNum)=2 && // forward 2 squares
                                                                        UDF_getRankFromSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum)=4 &&
                                                                        Switch(true,
                                                                            (
                                                                                Not(IsBlank(UDF_getFileNameFromSqName(theCurrentNode.inactiveColorMoveRecord.targetSquareName))) &&
                                                                                UDF_getFileNameFromSqName(theCurrentNode.inactiveColorMoveRecord.targetSquareName) in "a"
                                                                            ),
                                                                                Not(IsBlank(UDF_getBitAtSqNum(
                                                                                    theData.chessEngineData.tmpBoard,
                                                                                    UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,1,0)
                                                                                ))) &&
                                                                                UDF_getBitAtSqNum(
                                                                                    theData.chessEngineData.tmpBoard,
                                                                                    UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,1,0)
                                                                                ) exactin "p",
                                                                            (
                                                                                Not(IsBlank(UDF_getFileNameFromSqName(theCurrentNode.inactiveColorMoveRecord.targetSquareName))) &&
                                                                                UDF_getFileNameFromSqName(theCurrentNode.inactiveColorMoveRecord.targetSquareName) in "h"
                                                                            ),
                                                                                Not(IsBlank(UDF_getBitAtSqNum(
                                                                                    theData.chessEngineData.tmpBoard,
                                                                                    UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,-1,0)
                                                                                ))) &&
                                                                                UDF_getBitAtSqNum(
                                                                                    theData.chessEngineData.tmpBoard,
                                                                                    UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,-1,0)
                                                                                ) exactin "p",
                    
                                                                            // default
                                                                            (
                                                                                (
                                                                                    Not(IsBlank(UDF_getBitAtSqNum(
                                                                                        theData.chessEngineData.tmpBoard,
                                                                                        UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,-1,0)
                                                                                    ))) &&
                                                                                    UDF_getBitAtSqNum(
                                                                                        theData.chessEngineData.tmpBoard,
                                                                                        UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,-1,0)
                                                                                    ) exactin "p"
                                                                                ) ||
                                                                                (
                                                                                    Not(IsBlank(UDF_getBitAtSqNum(
                                                                                        theData.chessEngineData.tmpBoard,
                                                                                        UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,1,0)
                                                                                    ))) &&
                                                                                    UDF_getBitAtSqNum(
                                                                                        theData.chessEngineData.tmpBoard,
                                                                                        UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,1,0)
                                                                                    ) exactin "p"
                                                                                )
                                                                            )
                                                                        ),
                                                                            UDF_sqNumToSqName(UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,0,-1)),
                    
                                                                        UDF_FEN_TO_INACTIVE_COLOR(theCurrentNode.preMoveFEN)=WHITE &&
                                                                        (
                                                                            Not(IsBlank(theCurrentNode.inactiveColorMoveRecord.sourceSquareOccupier)) &&
                                                                            theCurrentNode.inactiveColorMoveRecord.sourceSquareOccupier exactin "p"
                                                                        ) && // PAWN move
                                                                        UDF_getRankFromSqNum(theCurrentNode.inactiveColorMoveRecord.sourceSquareNum)=7 && // forward 2 squares
                                                                        UDF_getRankFromSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum)=5 &&
                                                                        Switch(true,
                                                                            (
                                                                                Not(IsBlank(UDF_getFileNameFromSqName(theCurrentNode.inactiveColorMoveRecord.targetSquareName))) &&
                                                                                UDF_getFileNameFromSqName(theCurrentNode.inactiveColorMoveRecord.targetSquareName) in "a"
                                                                            ),
                                                                                Not(IsBlank(UDF_getBitAtSqNum(
                                                                                    theData.chessEngineData.tmpBoard,
                                                                                    UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,1,0)
                                                                                ))) &&
                                                                                UDF_getBitAtSqNum(
                                                                                    theData.chessEngineData.tmpBoard,
                                                                                    UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,1,0)
                                                                                ) exactin "P",
                                                                            (
                                                                                Not(IsBlank(UDF_getFileNameFromSqName(theCurrentNode.inactiveColorMoveRecord.targetSquareName))) &&
                                                                                UDF_getFileNameFromSqName(theCurrentNode.inactiveColorMoveRecord.targetSquareName) in "h"
                                                                            ),
                                                                                Not(IsBlank(UDF_getBitAtSqNum(
                                                                                    theData.chessEngineData.tmpBoard,
                                                                                    UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,-1,0)
                                                                                ))) &&
                                                                                UDF_getBitAtSqNum(
                                                                                    theData.chessEngineData.tmpBoard,
                                                                                    UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,-1,0)
                                                                                ) exactin "P",
                    
                                                                            // default
                                                                            (
                                                                                (
                                                                                    Not(IsBlank(UDF_getBitAtSqNum(
                                                                                        theData.chessEngineData.tmpBoard,
                                                                                        UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,-1,0)
                                                                                    ))) &&
                                                                                    UDF_getBitAtSqNum(
                                                                                        theData.chessEngineData.tmpBoard,
                                                                                        UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,-1,0)
                                                                                    ) exactin "P"
                                                                                ) ||
                                                                                (
                                                                                    Not(IsBlank(UDF_getBitAtSqNum(
                                                                                        theData.chessEngineData.tmpBoard,
                                                                                        UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,1,0)
                                                                                    ))) &&
                                                                                    UDF_getBitAtSqNum(
                                                                                        theData.chessEngineData.tmpBoard,
                                                                                        UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,1,0)
                                                                                    ) exactin "P"
                                                                                )
                                                                            )
                                                                        ),
                                                                            UDF_sqNumToSqName(UDF_getSqNumRelativeToSqNum(theCurrentNode.inactiveColorMoveRecord.targetSquareNum,0,1)),
                    
                                                                        // default
                                                                        "-"
                                                                    ),
                    
                                                                    If( // a pawn move or a capture resets the halfmove count
                                                                        (
                                                                            Not(IsBlank(theCurrentNode.inactiveColorMoveRecord.sourceSquareOccupier)) &&
                                                                            theCurrentNode.inactiveColorMoveRecord.sourceSquareOccupier in "P"
                                                                        ) ||
                                                                        (
                                                                            Not(IsBlank(theCurrentNode.inactiveColorMoveRecord.captureSquareOccupier)) &&
                                                                            theCurrentNode.inactiveColorMoveRecord.captureSquareOccupier in "QRBNP"
                                                                        ), 
                                                                        // THEN
                                                                        0, 
                    
                                                                        // ELSE
                                                                        UDF_FEN_TO_HALFMOVE_COUNT(theCurrentNode.preMoveFEN) + 1
                                                                    ),
                                                                    If(UDF_FEN_TO_FULLMOVE_COUNT(theCurrentNode.preMoveFEN)<=0,
                                                                        1,
                                                                        If(UDF_FEN_TO_ACTIVE_COLOR(theCurrentNode.preMoveFEN)=BLACK,
                                                                            UDF_FEN_TO_FULLMOVE_COUNT(theCurrentNode.preMoveFEN) + 1,
                                                                            UDF_FEN_TO_FULLMOVE_COUNT(theCurrentNode.preMoveFEN)
                                                                        )
                                                                    )
                                                                )
                                                        })
                                                    )
                                                );
                    
                                                comChessEngineFunctionsLibrary.fME_EvaluateMove(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.newNodeID);
                    
                                                With(
                                                    LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.newNodeID) As theCurrentNode,
                    
                                                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                        " GAME_NODES JUST FINISHED CREATING MT nodeID: " & theCurrentNode.nodeID & 
                                                        " parentNodeID: " & theCurrentNode.parentNodeID &
                                                        " nodeDepth: " & theCurrentNode.nodeDepth &
                                                        " preMoveFEN: " & theCurrentNode.preMoveFEN
                                                    });
                    
                                                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                        " san: " & theCurrentNode.inactiveColorMoveRecord.san &
                                                        " pacn: " & theCurrentNode.inactiveColorMoveRecord.pacn &
                                                        " centipawn: " & theCurrentNode.postMoveEvalRecord.centipawn &
                                                        " postMoveFEN: " & theCurrentNode.postMoveFEN & " ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                                                    })
                                                )
                                            ),
                    
                                            // ELSE - must have been a blocked slider
                                            Blank()
                                        )
                                    )
                                )
                            )
                        );
                    
                        // BEGIN DUMP ===============================================================================================
                        With(
                            LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                    
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " btnProcessGame.OnSelect(): Move Tree Dump preMoveFEN: " & theD0ParentNode.preMoveFEN
                            }); 
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " btnProcessGame.OnSelect():  postMoveFEN: " & theD0ParentNode.postMoveFEN
                            });
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                "  MT D0(" & theD0ParentNode.nodeID  & "/" & theD0ParentNode.inactiveColorMoveRecord.pacn & 
                                " " & theD0ParentNode.inactiveColorMoveRecord.promoteTo & "/" & UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN) & "-" & 
                                theD0ParentNode.postMoveNumActiveChecks & ") Num of children: " & CountRows(Filter(colPF_MOVE_TREE, parentNodeID=theD0ParentNode.nodeID))
                            });
                    
                            If(CountRows(Filter(colPF_MOVE_TREE, parentNodeID=theD0ParentNode.nodeID))>0,
                                // THEN
                                ForAll(
                                    Sort(Filter(colPF_MOVE_TREE, parentNodeID=theD0ParentNode.nodeID),inactiveColorMoveRecord.san) As aD1Node,
                    
                                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                        "  MT D0(" & theD0ParentNode.nodeID  & "/" & theD0ParentNode.inactiveColorMoveRecord.pacn & ")" &
                                        "->D1(" & aD1Node.nodeID &  "/" & aD1Node.inactiveColorMoveRecord.pacn & " " & aD1Node.inactiveColorMoveRecord.promoteTo & 
                                        "/" & aD1Node.inactiveColorMoveRecord.san & ")" &
                                        " nodeDepth: " & aD1Node.nodeDepth & " # of checks: " & aD1Node.postMoveNumActiveChecks &
                                        " centipawn: " & aD1Node.postMoveEvalRecord.centipawn
                                    })
                                )
                            )
                        );
                        // END DUMP ===============================================================================================
                    
                        // TIMER END - GAME_NODES ================================================================================
                        UpdateIf(colPF_Timers, timerName="btnProcessGame.GAME_NODES", { stopTime: Now() });
                        With(
                            LookUp(colPF_Timers, timerName="btnProcessGame.GAME_NODES") As theTimer,
                    
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " btnProcessGame.OnSelect(): GAME_NODES " &
                                Text(DateDiff(theTimer.startTime, theTimer.stopTime, TimeUnit.Milliseconds)/1000) & " seconds"
                            })
                        );
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " btnProcessGame.OnSelect(): finished  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                        });
                    
                    
                        /* -----------------------------------------------------------------------------------------------------------------------------------------------------------
                        GAME_SAN_D1
                    
                        - moves 0+
                        - go through D1 nodes and determine the following SAN fields for each D1 move
                        - SAN_PIECECODE SAN_DISAMBIGUATION SAN_CAPTURE_FLAG SAN_TARGET_SQUARE SAN_PROMOTION SAN_CHECK_CHECKMATE
                        */
                    
                        // THEN - TIMER START - GAME_SAN_D1 ================================================================================
                        If(IsBlank(LookUp(colPF_Timers, timerName="btnProcessGame.GAME_SAN_D1")),
                            Collect(colPF_Timers, {timerName:"btnProcessGame.GAME_SAN_D1",startTime:Now(),stopTime:Blank()}),
                            UpdateIf(colPF_Timers, timerName="btnProcessGame.GAME_SAN_D1", { startTime: Now() })
                        );
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " btnProcessGame.OnSelect(): GAME_SAN_D1 getting started...   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv"
                        });
                    
                        With(
                            LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                    
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " btnProcessGame.OnSelect(): GAME_SAN_D1 test #: " & theData.chessEngineData.testNumber & 
                                " move #: " & theData.chessEngineData.moveNumber & " testCount: " & theData.chessEngineData.testCount
                            })
                        );
                    
                        ForAll (
                            Filter(colPF_MOVE_TREE, nodeDepth=1) As aD1Node,
                    
                            If(Not(IsMatch(aD1Node.inactiveColorMoveRecord.san,"O-O",MatchOptions.BeginsWith)),
                                // THEN - normal SAN processing
                                UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                    chessEngineData:    
                                        Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                            SAN_PIECECODE:
                                                If(
                                                    (
                                                        Not(IsBlank(aD1Node.inactiveColorMoveRecord.sourceSquareOccupier)) &&
                                                        aD1Node.inactiveColorMoveRecord.sourceSquareOccupier in "P"
                                                    ),
                                                    If(aD1Node.inactiveColorMoveRecord.captureSquareNum=EMPTY_SQUARE_NUM,
                                                        "",
                                                        UDF_getFileNameFromSqName(aD1Node.inactiveColorMoveRecord.sourceSquareName)
                                                    ),
                                                    Upper(aD1Node.inactiveColorMoveRecord.sourceSquareOccupier)
                                                ),
                                            SAN_DISAMBIGUATION:         "",
                                            SAN_DISAMBIGUATION_COUNT:
                                                CountRows(Filter(colPF_MOVE_TREE, nodeDepth=1 &&
                                                    inactiveColorMoveRecord.sourceSquareNum<>aD1Node.inactiveColorMoveRecord.sourceSquareNum &&
                                                    inactiveColorMoveRecord.sourceSquareOccupier=aD1Node.inactiveColorMoveRecord.sourceSquareOccupier &&
                                                    inactiveColorMoveRecord.targetSquareNum=aD1Node.inactiveColorMoveRecord.targetSquareNum
                                                )),
                                            SAN_DISAMBIGUATION_COL_COUNT:
                                                CountRows(Filter(colPF_MOVE_TREE, nodeDepth=1 &&
                                                    inactiveColorMoveRecord.sourceSquareNum<>aD1Node.inactiveColorMoveRecord.sourceSquareNum &&
                                                    inactiveColorMoveRecord.sourceSquareOccupier=aD1Node.inactiveColorMoveRecord.sourceSquareOccupier &&
                                                    inactiveColorMoveRecord.targetSquareNum=aD1Node.inactiveColorMoveRecord.targetSquareNum &&
                                                    Left(inactiveColorMoveRecord.sourceSquareName,1)=Left(aD1Node.inactiveColorMoveRecord.sourceSquareName,1) // same column
                                                )),
                                            SAN_DISAMBIGUATION_ROW_COUNT:
                                                CountRows(Filter(colPF_MOVE_TREE, nodeDepth=1 &&
                                                    inactiveColorMoveRecord.sourceSquareNum<>aD1Node.inactiveColorMoveRecord.sourceSquareNum &&
                                                    inactiveColorMoveRecord.sourceSquareOccupier=aD1Node.inactiveColorMoveRecord.sourceSquareOccupier &&
                                                    inactiveColorMoveRecord.targetSquareNum=aD1Node.inactiveColorMoveRecord.targetSquareNum &&
                                                    Right(inactiveColorMoveRecord.sourceSquareName,1)=Right(aD1Node.inactiveColorMoveRecord.sourceSquareName,1) // same row
                                                )),
                                            SAN_CAPTURE_FLAG:
                                                If(aD1Node.inactiveColorMoveRecord.captureSquareNum=EMPTY_SQUARE_NUM,"","x"),
                                            SAN_PROMOTION:
                                                If(IsBlank(aD1Node.inactiveColorMoveRecord.promoteTo),EMPTY_ABBR,"=" & aD1Node.inactiveColorMoveRecord.promoteTo),
                                            SAN_CHECK_CHECKMATE:
                                                If(
                                                    (UDF_FEN_TO_ACTIVE_COLOR(aD1Node.postMoveFEN)=WHITE && aD1Node.postMoveGameStatus.whiteIsCheckmated) ||
                                                    (UDF_FEN_TO_ACTIVE_COLOR(aD1Node.postMoveFEN)=BLACK && aD1Node.postMoveGameStatus.blackIsCheckmated),
                    
                                                    // THEN
                                                    "#",
                    
                                                    // ELSE
                    /*
                                                    If(
                                                        aD1Node.postMoveNumActiveChecks>0 ||
                                                        (
                                                            UDF_isSqNumAttacked(
                                                                // THEN
                                                                UDF_FEN_TO_BOARD(aD1Node.postMoveFEN),
                                                                UDF_SearchBoardForPiece(UDF_FEN_TO_BOARD(aD1Node.postMoveFEN), UDF_getACPieceABBR(aD1Node.postMoveFEN,"K")),
                                                                UDF_FEN_TO_INACTIVE_COLOR(aD1Node.postMoveFEN)
                                                            )
                                                        ),
                                                        // THEN
                                                        "+",
                     */
                                                    If(aD1Node.postMoveNumActiveChecks>0,
                                                        // THEN
                                                        "+",
                    
                                                        // ELSE
                                                        ""
                                                    )
                                                )
                                        })
                                });
                    
                                With(
                                    LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                    
                                    Switch(true,
                                        // Is there a need for disambiguation
                                        theData.chessEngineData.SAN_DISAMBIGUATION_COUNT=0,
                                            // DISAMBIGUATION is not needed
                                            UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                        SAN_DISAMBIGUATION: ""
                                                                    })
                                            }),
                    
                                        // can we do just column disambiguation ?
                                        theData.chessEngineData.SAN_DISAMBIGUATION_COL_COUNT=0,
                                            // use column to disambiguate pieces on same row
                                            UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                        SAN_DISAMBIGUATION: Left(aD1Node.inactiveColorMoveRecord.sourceSquareName,1)
                                                                    })
                                            }),
                                        // can we do just row disambiguation ?
                                        theData.chessEngineData.SAN_DISAMBIGUATION_ROW_COUNT=0,
                                            // use row to disambiguate pieces on same column
                                            UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                        SAN_DISAMBIGUATION: Right(aD1Node.inactiveColorMoveRecord.sourceSquareName,1)
                                                                    })
                                            }),
                                        // default - got to use full disambiguation
                                        UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                            chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                    SAN_DISAMBIGUATION: aD1Node.inactiveColorMoveRecord.sourceSquareName
                                                                })
                                        })
                                    );
                    
                                    // special gotcha case #1 - if this is a PAWN capture do NOT need both SAN_PIECECODE & SAN_DISAMBIGUATION set
                                    With(
                                        LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theUpdatedData,
                    
                                        If(
                                            (
                                                Not(IsBlank(aD1Node.inactiveColorMoveRecord.sourceSquareOccupier)) &&
                                                aD1Node.inactiveColorMoveRecord.sourceSquareOccupier in "P"
                                            ) &&
                                            Not(IsBlank(theUpdatedData.chessEngineData.SAN_CAPTURE_FLAG)) &&
                                            Not(IsBlank(theUpdatedData.chessEngineData.SAN_PIECECODE)) &&
                                            Not(IsBlank(theUpdatedData.chessEngineData.SAN_DISAMBIGUATION)),
                                            // THEN this is the special case - get rid of SAN_PIECECODE
                                            UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                                chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                        SAN_PIECECODE: ""
                                                                    })
                                            })
                                        )
                                    )
                                );
                    
                                With(
                                    LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                    
                                    UpdateIf(colPF_MOVE_TREE, nodeID=aD1Node.nodeID, {
                                        inactiveColorMoveRecord:    Patch(LookUp(colPF_MOVE_TREE, nodeID=aD1Node.nodeID).inactiveColorMoveRecord, {
                                                                        san:    theData.chessEngineData.SAN_PIECECODE &
                                                                                theData.chessEngineData.SAN_DISAMBIGUATION &
                                                                                theData.chessEngineData.SAN_CAPTURE_FLAG &
                                                                                aD1Node.inactiveColorMoveRecord.targetSquareName &
                                                                                theData.chessEngineData.SAN_PROMOTION &
                                                                                theData.chessEngineData.SAN_CHECK_CHECKMATE
                                                                    })
                                    })
                                )
                            )
                        );
                    
                        // TIMER END - GAME_SAN_D1 ================================================================================
                        UpdateIf(colPF_Timers, timerName="btnProcessGame.GAME_SAN_D1", { stopTime: Now() });
                        With(
                            LookUp(colPF_Timers, timerName="btnProcessGame.GAME_SAN_D1") As theTimer,
                    
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " btnProcessGame.OnSelect(): " &
                                Text(DateDiff(theTimer.startTime, theTimer.stopTime, TimeUnit.Milliseconds)/1000) & " seconds"
                            })
                        );
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " btnProcessGame.OnSelect(): GAME_SAN_D1 finished   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                        });
                    
                        With(
                            LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                    
                            With(
                                LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                    
                                ForAll(
                                    Sequence(3) As theCount,
                    
                                    With(
                                        Last(
                                            FirstN(
                                                Sort(
                                                    Filter(colPF_MOVE_TREE, nodeDepth=1),
                                                    postMoveEvalRecord.centipawn, 
                                                    If(UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE,SortOrder.Descending,SortOrder.Ascending)
                                                ), theCount.Value
                                            ) 
                                        ) As theTopMoves,
                    
                                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                            " btnProcessGame.OnSelect(): pre-GAME_STATUS_POST_D1 DEBUG dumping current top moves" & 
                                            " count: " & theCount.Value &
                                            " san: " & theTopMoves.inactiveColorMoveRecord.san & 
                                            " pacn: " & theTopMoves.inactiveColorMoveRecord.pacn &
                                            " centipawn: " & theTopMoves.postMoveEvalRecord.centipawn
                                        })
                                    )
                                )
                            )
                        );
                    
                        /* -----------------------------------------------------------------------------------------------------------------------------------------------------------
                        GAME_STATUS_POST_D1
                    
                        - moves 0+
                        - populate remaining D0 post move fields for "current" (move tree D0) position
                        - these are the fields that can only be determined after the D1 moves are known
                        - CHECKMATE
                        - STALEMATE
                    
                        TODO...
                        - DRAWs
                        */
                    
                        // THEN - TIMER START - GAME_STATUS ================================================================================
                        If(IsBlank(LookUp(colPF_Timers, timerName="btnProcessGame.GAME_STATUS_POST_D1")),
                            Collect(colPF_Timers, {timerName:"btnProcessGame.GAME_STATUS_POST_D1",startTime:Now(),stopTime:Blank()}),
                            UpdateIf(colPF_Timers, timerName="btnProcessGame.GAME_STATUS_POST_D1", { startTime: Now() })
                        );
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " btnProcessGame.OnSelect(): GAME_STATUS_POST_D1 getting started  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv"
                        });
                    
                        With(
                            LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                    
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " btnProcessGame.OnSelect(): GAME_STATUS_POST_D1 test #: " & theData.chessEngineData.testNumber & 
                                " move #: " & theData.chessEngineData.moveNumber & " testCount: " & theData.chessEngineData.testCount &
                                " isGame: " & theData.chessEngineData.isGame
                            });
                    
                            With(
                                LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                    
                                If(CountRows(Filter(colPF_MOVE_TREE, nodeDepth=1))>0,
                                    // THEN - there is no CHECKMATE or STALEMATE
                                    UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                        postMoveGameStatus:     Patch(
                                                                    LookUp(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID).postMoveGameStatus,
                                                                    {
                                                                        whiteIsCheckmated:        false,
                                                                        blackIsCheckmated:        false,
                                                                        isStalemate:            false
                                                                    }
                                                                )
                                    }),
                    
                                    // ELSE - got either a CHECKMATE or a STALEMATE
                                    If(theD0ParentNode.postMoveNumActiveChecks>0,
                                        // THEN - got a CHECKMATE
                                        UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                            postMoveGameStatus:     Patch(
                                                                        LookUp(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID).postMoveGameStatus,
                                                                        {
                                                                            whiteIsCheckmated:        If(UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE,true,false),
                                                                            blackIsCheckmated:        If(UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=BLACK,true,false),
                                                                            isStalemate:            false
                                                                        }
                                                                    )
                                        }),
                    
                                        // ELSE - got a STALEMATE
                                        UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                            postMoveGameStatus:     Patch(
                                                                        LookUp(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID).postMoveGameStatus,
                                                                        {
                                                                            whiteIsCheckmated:        false,
                                                                            blackIsCheckmated:        false,
                                                                            isStalemate:            true
                                                                        }
                                                                    )
                                        })
                                    )
                                )
                            )
                        );
                    
                        With(
                            LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                    
                            Switch(true,
                                Not(IsMatch(theD0ParentNode.inactiveColorMoveRecord.san, "#", MatchOptions.Contains)) &&
                                (
                                    theD0ParentNode.postMoveGameStatus.whiteIsCheckmated || 
                                    theD0ParentNode.postMoveGameStatus.blackIsCheckmated
                                ),
                                    // Add CHECKMATE tail '#' to SAN
                                    UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                        inactiveColorMoveRecord:    Patch(
                                                                        theD0ParentNode.inactiveColorMoveRecord,
                                                                        {
                                                                            san:        Substitute(theD0ParentNode.inactiveColorMoveRecord.san, "+", "") & "#"
                                                                        }
                                                                    )
                                    }),
                    
                                Not(IsMatch(theD0ParentNode.inactiveColorMoveRecord.san, "\+", MatchOptions.Contains)) &&
                                theD0ParentNode.postMoveNumActiveChecks>0,
                                    // Add CHECK tail '+' to SAN
                                    UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                        inactiveColorMoveRecord:    Patch(
                                                                        theD0ParentNode.inactiveColorMoveRecord,
                                                                        {
                                                                            san:        Substitute(theD0ParentNode.inactiveColorMoveRecord.san, "+", "") & "+"
                                                                        }
                                                                    )
                                    })
                            )
                        );
                    
                    
                        // TIMER END - GAME_STATUS ================================================================================
                        UpdateIf(colPF_Timers, timerName="btnProcessGame.GAME_STATUS_POST_D1", { stopTime: Now() });
                        With(
                            LookUp(colPF_Timers, timerName="btnProcessGame.GAME_STATUS_POST_D1") As theTimer,
                    
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " btnProcessGame.OnSelect(): " &
                                Text(DateDiff(theTimer.startTime, theTimer.stopTime, TimeUnit.Milliseconds)/1000) & " seconds"
                            })
                        );
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " btnProcessGame.OnSelect(): GAME_STATUS_POST_D1  finished   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                        });
                    
                        /* -----------------------------------------------------------------------------------------------------------------------------------------------------------
                        GAME_MOVE_HISTORY_D0
                    
                        - moves 1+
                        - append move tree D0 node to move history making it the new TAIL
                        - if this is M1 then this will be the move history HEAD and TAIL
                        - NOTE: if M0 is an end of game and no move is actually made then NOTHING gets appended to move history
                        */
                        With(
                            LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                    
                            If(theData.chessEngineData.moveNumber>=1,
                                // THEN - TIMER START - GAME_MOVE_HISTORY_D0 ================================================================================
                                If(IsBlank(LookUp(colPF_Timers, timerName="btnProcessGame.GAME_MOVE_HISTORY_D0")),
                                    Collect(colPF_Timers, {timerName:"btnProcessGame.GAME_MOVE_HISTORY_D0",startTime:Now(),stopTime:Blank()}),
                                    UpdateIf(colPF_Timers, timerName="btnProcessGame.GAME_MOVE_HISTORY_D0", { startTime: Now() })
                                );
                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                    " btnProcessGame.OnSelect(): GAME_MOVE_HISTORY_D0 getting started   vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv"
                                });
                    
                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                    " btnProcessGame.OnSelect(): GAME_MOVE_HISTORY_D0 test #: " & theData.chessEngineData.testNumber & 
                                    " move #: " & theData.chessEngineData.moveNumber & " testCount: " & theData.chessEngineData.testCount
                                });
                    
                                If(CountRows(colPF_MOVE_HISTORY)=0,
                                    // THEN - this is the first move of game - need to make it the root node in move history collection 
                                    Patch(colPF_MOVE_HISTORY, Defaults(colPF_MOVE_HISTORY), 
                                        LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID)
                                    );
                    
                                    UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                        chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                moveHistoryHEADNodeID:  LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID,
                                                                moveHistoryTAILNodeID:  LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID
                                                            })
                                    }),
                    
                                    // ELSE move 2+ of the game
                                    UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                        chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                newNodeID:  Max(colPF_MOVE_HISTORY, nodeID) + 1
                                                            })
                                    });
                    
                                    Patch(colPF_MOVE_HISTORY, Defaults(colPF_MOVE_HISTORY), 
                                        Patch(
                                            LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID),
                                            {
                                                nodeID:             LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.newNodeID,
                                                parentNodeID:       LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveHistoryTAILNodeID
                                            }
                                        )
                                    );
                    
                                    UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                        chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                                moveHistoryTAILNodeID:  LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.newNodeID
                                                            })
                                    })
                                );
                    
                                // TIMER END - GAME_MOVE_HISTORY_D0 ================================================================================
                                UpdateIf(colPF_Timers, timerName="btnProcessGame.GAME_MOVE_HISTORY_D0", { stopTime: Now() });
                                With(
                                    LookUp(colPF_Timers, timerName="btnProcessGame.GAME_MOVE_HISTORY_D0") As theTimer,
                    
                                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                        " btnProcessGame.OnSelect(): GAME_MOVE_HISTORY_D0 " &
                                        Text(DateDiff(theTimer.startTime, theTimer.stopTime, TimeUnit.Milliseconds)/1000) & " seconds"
                                    })
                                );
                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                    " btnProcessGame.OnSelect(): GAME_MOVE_HISTORY_D0 finished  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                                })
                            );
                    
                    
                            // DRAWs - TODO...
                            // if the number of moves is >= 6 AND
                            //      latest board, board-2, and board-4 is all the same   AND  
                            //      board-1, board-3, and board-5 is all the same -> DRAW due to repeat postitions
                            If(CountRows(colPF_MOVE_HISTORY)>=8,
                                // THEN
                                With(
                                    LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                    
                                    With(
                                        LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                    
                                        If(
                                            Not(
                                                theD0ParentNode.postMoveGameStatus.whiteIsCheckmated ||
                                                theD0ParentNode.postMoveGameStatus.blackIsCheckmated ||
                                                theD0ParentNode.postMoveGameStatus.isStalemate ||
                                                theD0ParentNode.postMoveGameStatus.isDraw
                                            ),
                                            // Then check for a position repeat draw
                    
                                            With(
                                                LookUp(colPF_MOVE_HISTORY, nodeID=theData.chessEngineData.moveHistoryTAILNodeID) As theTail,
                    
                                                With(
                                                    LookUp(colPF_MOVE_HISTORY, nodeID=theTail.parentNodeID) As theTail_minus1,
                                                    
                                                    With(
                                                        LookUp(colPF_MOVE_HISTORY, nodeID=theTail_minus1.parentNodeID) As theTail_minus2,
                                                    
                                                        With(
                                                            LookUp(colPF_MOVE_HISTORY, nodeID=theTail_minus2.parentNodeID) As theTail_minus3,
                                                    
                                                            With(
                                                                LookUp(colPF_MOVE_HISTORY, nodeID=theTail_minus3.parentNodeID) As theTail_minus4,
                                                    
                                                                With(
                                                                    LookUp(colPF_MOVE_HISTORY, nodeID=theTail_minus4.parentNodeID) As theTail_minus5,
                    
                                                                    With(
                                                                        LookUp(colPF_MOVE_HISTORY, nodeID=theTail_minus5.parentNodeID) As theTail_minus6,
                    
                                                                        With(
                                                                            LookUp(colPF_MOVE_HISTORY, nodeID=theTail_minus6.parentNodeID) As theTail_minus7,
                    
                    
                                                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                                                " btnProcessGame.OnSelect(): 3x position repeat DRAW detection "
                                                                            });
                                                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                                                " board:    " & UDF_FEN_TO_PIECE_PLACMENT(theTail.postMoveFEN)
                                                                            });
                                                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                                                " board_m1: " & UDF_FEN_TO_PIECE_PLACMENT(theTail_minus1.postMoveFEN)
                                                                            });
                                                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                                                " board_m2: " & UDF_FEN_TO_PIECE_PLACMENT(theTail_minus2.postMoveFEN)
                                                                            });
                                                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                                                " board_m3: " & UDF_FEN_TO_PIECE_PLACMENT(theTail_minus3.postMoveFEN)
                                                                            });
                                                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                                                " board_m4: " & UDF_FEN_TO_PIECE_PLACMENT(theTail_minus4.postMoveFEN)
                                                                            });
                                                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                                                " board_m5: " & UDF_FEN_TO_PIECE_PLACMENT(theTail_minus5.postMoveFEN)
                                                                            });
                                                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                                                " board_m6: " & UDF_FEN_TO_PIECE_PLACMENT(theTail_minus6.postMoveFEN)
                                                                            });
                                                                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                                                                " board_m7: " & UDF_FEN_TO_PIECE_PLACMENT(theTail_minus7.postMoveFEN)
                                                                            });
                    
                                                                            If(
                                                                                UDF_FEN_TO_PIECE_PLACMENT(theTail.postMoveFEN)=UDF_FEN_TO_PIECE_PLACMENT(theTail_minus4.postMoveFEN) &&
                                                                                UDF_FEN_TO_PIECE_PLACMENT(theTail_minus1.postMoveFEN)=UDF_FEN_TO_PIECE_PLACMENT(theTail_minus5.postMoveFEN) &&
                                                                                UDF_FEN_TO_PIECE_PLACMENT(theTail_minus2.postMoveFEN)=UDF_FEN_TO_PIECE_PLACMENT(theTail_minus6.postMoveFEN) &&
                                                                                UDF_FEN_TO_PIECE_PLACMENT(theTail_minus3.postMoveFEN)=UDF_FEN_TO_PIECE_PLACMENT(theTail_minus7.postMoveFEN),
                                                                                // THEN - we got ourselves a DRAW due to repeating postions
                    
                                                                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                                                                    " btnProcessGame.OnSelect(): 3x position repeat DRAW detected sitting isDraw to true "
                                                                                });
                    
                                                                                UpdateIf(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID, {
                                                                                    postMoveGameStatus:     Patch(
                                                                                                                LookUp(colPF_MOVE_TREE, nodeID=theD0ParentNode.nodeID).postMoveGameStatus,
                                                                                                                {
                                                                                                                    isDraw:                 true
                                                                                                                }
                                                                                                            )
                                                                                })
                                                                            )
                                                                        )
                                                                    )
                                                                )
                                                            )
                                                        )
                                                    )
                                                )
                                            )
                                        )
                                    )
                                )
                            );
                    
                            If(theData.chessEngineData.isGame,
                                // THEN - either game or game test
                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                    " btnProcessGame.OnSelect(): selecting 'btnCheckGameResults'"
                                });
                                Select(btnCheckGameResults),
                    
                                // ELSE - this is a test
                                Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                                    " btnProcessGame.OnSelect(): selecting 'btnCheckTestResults'"
                                });
                                Select(btnCheckTestResults)
                            )
                        );
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                            " btnProcessGame.OnSelect(): DEBUG breakpoint 0001"
                        }),
                    
                        // ELSE
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                            " btnProcessGame.OnSelect(): DEBUG breakpoint 0002  PAUSED"
                        });
                        With(
                            LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                    
                            Set(gblPF_UI_StatusText, "PAUSED");
                            Set(gblPF_UI_StatusFill, COLOR_YELLOWish);
                            Set(gblPF_UI_DiagnosticText, theData.uiData.diagnosticText);
                            Set(gblPF_UI_DiagnosticFill, theData.uiData.diagnosticFill);
                    
                            With(
                                LookUp(colPF_MOVE_HISTORY, nodeID=theData.chessEngineData.moveHistoryTAILNodeID) As theD0ParentNode,
                    
                                If(!IsBlank(theD0ParentNode),
                                    Set(gblPF_UI_GamePhase, "OPENING"),
                                    Set(gblPF_UI_GamePhase, "")
                                )
                            )
                        )
                    );
                    
                    Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") &
                        " btnProcessGame.OnSelect(): DEBUG breakpoint 0003  exiting"
                    });
                    
                    
                    
                    
                Text: ="Button"
                Visible: =false
                X: =100
                Y: =100
                ZIndex: =4

            btnNewGame As button:
                OnSelect: |
                    =comUtilityFunctionsLibrary.fUtilInitData(1);
                    
                    
                    
                    /*  -------------------------------------------------------------------------------------------------------------------------------------------------
                    NEW_GAME
                    
                    - move M0 only
                    - game initialization - make the starting position the "current" (move tree D0) position
                      - populate all post move D0 fields that can be derived from FEN
                     */
                    
                    With(
                        LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                    
                        Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                            " btnNewGame_CB.OnSelect(): NEW_GAME getting started vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv"
                        });
                        If(IsBlank(LookUp(colPF_Timers, timerName="btnNewGame_CB.NEW_GAME")),
                            Collect(colPF_Timers, {timerName:"btnNewGame_CB.NEW_GAME",startTime:Now(),stopTime:Blank()}),
                            UpdateIf(colPF_Timers, timerName="btnNewGame_CB.NEW_GAME", { startTime: Now() })
                        );
                        
                        If(theData.uiData.modeText="Diagnostic Mode",
                            // THEN
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " btnNewGame_CB.OnSelect(): NEW_GAME starting test #: " & theData.chessEngineData.testNumber 
                            }),
                    
                            // ELSE
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " btnNewGame_CB.OnSelect(): NEW_GAME starting game - player is : " & theData.chessEngineData.playerColor 
                            })
                        );
                        
                        Patch(colPF_MOVE_TREE, Defaults(colPF_MOVE_TREE), {
                            nodeID:                 	    ROOT_NODE_ID,
                            parentNodeID:           	    EMPTY_NODE_ID,
                            nodeDepth:					    0,
                            preMoveFEN:                     theData.chessEngineData.startingFEN,
                            postMoveFEN:                    theData.chessEngineData.startingFEN
                        });
                    
                        Set(gblPF_UI_DisplayedBoard, UDF_FEN_TO_BOARD(theData.chessEngineData.startingFEN));
                        Set(gblPF_UI_GameTurn, UDF_FEN_TO_ACTIVE_COLOR(theData.chessEngineData.startingFEN));
                    
                        UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                            chessEngineData:    Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData, {
                                                    moveTreeD0NodeID:       ROOT_NODE_ID,
                                                    moveHistoryHEADNodeID:  EMPTY_NODE_ID,
                                                    moveHistoryTAILNodeID:  EMPTY_NODE_ID
                                                })
                        });
                    
                        // TIMER END - NEW_GAME ================================================================================
                        UpdateIf(colPF_Timers, timerName="btnNewGame_CB.NEW_GAME", { stopTime: Now() });
                        With(
                            LookUp(colPF_Timers, timerName="btnNewGame_CB.NEW_GAME") As theTimer,
                    
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " btnNewGame_CB.OnSelect():   Completed NEW_GAME "  &
                                Text(DateDiff(theTimer.startTime, theTimer.stopTime, TimeUnit.Milliseconds)/1000) & " seconds ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
                            })
                        );
                    
                        With(
                            LookUp(colPF_MOVE_TREE, nodeID=LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                    
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " btnNewGame_CB.OnSelect(): NEW_GAME DEBUG postMoveFEN: " & theD0ParentNode.postMoveFEN
                            });
                            Collect(colPF_logs, {logOffset: GET_LOG_INDEX, logEntry: Text(Now(), "mm/dd/yyyy hh:mm:ss.fff") & 
                                " DEBUG postMoveBoard: " & UDF_FEN_TO_BOARD(theD0ParentNode.postMoveFEN)
                            });
                    
                            If(theData.chessEngineData.isGame,
                                // THEN
                                If(UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=theData.chessEngineData.playerColor,
                                    // THEN - the player needs to make a move
                                    UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                        uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                    statusText:     "Game in Progress" ,
                                                    statusFill:     COLOR_GREENish,
                                                    diagnosticText: "Player's Turn coming up",
                                                    diagnosticFill: COLOR_GREENish
                                                })
                                    }),
                    
                                    // Computer needs to make a play
                                    UpdateIf(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME, {
                                        uiData: Patch(LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData, {
                                                    statusText:             "Game in Progress" ,
                                                    statusFill:             COLOR_GREENish,
                                                    diagnosticText:         "Computer's turn - please wait...",
                                                    diagnosticFill:         COLOR_WHITEish
                                                })
                                    })
                                )
                            );
                            Select(btnProcessGame)
                        )
                    );
                Text: ="Button"
                Visible: =false
                X: =120
                Y: =120
                ZIndex: =5

            btnPause As button:
                OnSelect: |
                    =If(gblPF_PAUSE,
                        // THEN - unpause
                        Set(gblPF_PAUSE,false);
                        Select(btnProcessGame),
                    
                        // ELSE - pause
                        Set(gblPF_PAUSE,true)
                    );
                Text: =If(gblPF_PAUSE,">","||")
                Width: =45
                X: =35
                Y: =5
                ZIndex: =6

        lblBestMoveLine_M2 As label:
            BorderThickness: =1
            Height: =lblBestMoveLine_M1.Height
            Size: =11
            Text: |-
                =IfError(
                    With(
                        LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                
                        With(
                            LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                
                            With(
                                Last(
                                    FirstN(
                                        Sort(
                                            Filter(colPF_MOVE_TREE, nodeDepth=1), 
                                            postMoveEvalRecord.centipawn, 
                                            If(UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE,
                                                SortOrder.Descending,
                                                SortOrder.Ascending
                                            )
                                        ), 3
                                    )
                                )
                                As theMove,
                
                                Text(UDF_FEN_TO_FULLMOVE_COUNT(theD0ParentNode.postMoveFEN)) & 
                                If(UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE,". ","... ") & 
                                theMove.inactiveColorMoveRecord.san
                            )
                        )
                    ),
                    ""
                )
            Width: =lblBestMoveLine_M1.Width
            X: =973
            Y: =lblBestMoveLine_M1.Y + lblBestMoveLine_M1.Height + 5
            ZIndex: =4

        lblBestMoveMaterial_M2 As label:
            BorderThickness: =1
            Height: =lblBestMoveMaterial_M1.Height
            Size: =10
            Text: |-
                =IfError(
                    With(
                        LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                
                        With(
                            LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                
                            With(
                                Last(
                                    FirstN(
                                        Sort(
                                            Filter(colPF_MOVE_TREE, nodeDepth=1), 
                                            postMoveEvalRecord.centipawn, 
                                            If(UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE,
                                                SortOrder.Descending,
                                                SortOrder.Ascending
                                            )
                                        ), 3
                                    )
                                )
                                As theMove,
                
                                If(theMove.postMoveEvalRecord.centipawn>=0,"+","") &
                                    Text(theMove.postMoveEvalRecord.centipawn/100, "##.00")
                
                            )
                        )
                    ),
                    ""
                )
            Width: =lblBestMoveMaterial_M1.Width
            X: =908
            Y: =lblBestMoveMaterial_M1.Y + lblBestMoveMaterial_M1.Height + 5
            ZIndex: =5

        lblBestMoveLine_M1 As label:
            BorderThickness: =1
            Height: =lblBestMoveLine.Height
            Size: =11
            Text: |-
                =IfError(
                    With(
                        LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                
                        With(
                            LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                
                            With(
                                Last(
                                    FirstN(
                                        Sort(
                                            Filter(colPF_MOVE_TREE, nodeDepth=1), 
                                            postMoveEvalRecord.centipawn, 
                                            If(UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE,
                                                SortOrder.Descending,
                                                SortOrder.Ascending
                                            )
                                        ), 2
                                    )
                                )
                                As theMove,
                
                                Text(UDF_FEN_TO_FULLMOVE_COUNT(theD0ParentNode.postMoveFEN)) & 
                                If(UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE,". ","... ") & 
                                theMove.inactiveColorMoveRecord.san
                            )
                        )
                    ),
                    ""
                )
            Width: =lblBestMoveLine.Width
            X: =973
            Y: =lblBestMoveLine.Y + lblBestMoveLine.Height + 5
            ZIndex: =6

        lblBestMoveMaterial_M1 As label:
            BorderThickness: =1
            Height: =lblBestMoveMaterial.Height
            Size: =10
            Text: |-
                =IfError(
                    With(
                        LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                
                        With(
                            LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                
                            With(
                                Last(
                                    FirstN(
                                        Sort(
                                            Filter(colPF_MOVE_TREE, nodeDepth=1), 
                                            postMoveEvalRecord.centipawn, 
                                            If(UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE,
                                                SortOrder.Descending,
                                                SortOrder.Ascending
                                            )
                                        ), 2
                                    )
                                )
                                As theMove,
                
                                If(theMove.postMoveEvalRecord.centipawn>=0,"+","") &
                                    Text(theMove.postMoveEvalRecord.centipawn/100, "##.00")
                
                            )
                        )
                    ),
                    ""
                )
            Width: =lblBestMoveMaterial.Width
            X: =908
            Y: =lblBestMoveMaterial.Y + lblBestMoveMaterial.Height + 5
            ZIndex: =7

        lblBestMoveLine As label:
            BorderThickness: =1
            Height: =lblBestMoveMaterial.Height
            Size: =11
            Text: |-
                =IfError(
                    With(
                        LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                
                        With(
                            LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                
                            With(
                                First(
                                    Sort(
                                        Filter(colPF_MOVE_TREE, nodeDepth=1), 
                                        postMoveEvalRecord.centipawn, 
                                        If(UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE,
                                            SortOrder.Descending,
                                            SortOrder.Ascending
                                        )
                                    )
                                )
                                As theMove,
                
                                Text(UDF_FEN_TO_FULLMOVE_COUNT(theD0ParentNode.postMoveFEN)) & 
                                If(UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE,". ","... ") & 
                                theMove.inactiveColorMoveRecord.san
                            )
                        )
                    ),
                    ""
                )
            X: =973
            Y: =lblBestMoveMaterial.Y
            ZIndex: =8

        lblBestMoveMaterial As label:
            BorderThickness: =1
            Height: =20
            Size: =10
            Text: |-
                =IfError(
                    With(
                        LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME) As theData,
                
                        With(
                            LookUp(colPF_MOVE_TREE, nodeID=theData.chessEngineData.moveTreeD0NodeID) As theD0ParentNode,
                
                            With(
                                First(
                                    Sort(
                                        Filter(colPF_MOVE_TREE, nodeDepth=1), 
                                        postMoveEvalRecord.centipawn, 
                                        If(UDF_FEN_TO_ACTIVE_COLOR(theD0ParentNode.postMoveFEN)=WHITE,
                                            SortOrder.Descending,
                                            SortOrder.Ascending
                                        )
                                    )
                                )
                                As theMove,
                
                                If(theMove.postMoveEvalRecord.centipawn>=0,"+","") &
                                    Text(theMove.postMoveEvalRecord.centipawn/100, "##.00")
                
                            )
                        )
                    ),
                    ""
                )
            Width: =65
            X: =908
            Y: =690
            ZIndex: =9

        lblDisplayedFEN As label:
            Font: =Font.'Courier New'
            Text: |-
                ="FEN: " & gblPF_UI_DisplayedFEN
            Width: =875
            X: =10
            Y: =725
            ZIndex: =10

        btnGotoLogs As button:
            Height: =30
            OnSelect: =Navigate(Logging_Screen)
            Size: =11
            Text: ="Goto Logs"
            Width: =100
            X: =1250
            Y: =730
            ZIndex: =11

        lblBlackCapturedPieces As label:
            Height: =lblWhiteCapturedPieces.Height
            Text: =gblPF_UI_blackCapturedPieces
            Width: =lblWhiteCapturedPieces.Width
            X: =lblWhiteCapturedPieces.X + lblWhiteCapturedPieces.Width
            Y: =lblWhiteCapturedPieces.Y
            ZIndex: =12

        lblWhiteCapturedPieces As label:
            Height: =lblMaterialOverall.Height
            Text: =gblPF_UI_whiteCapturedPieces
            Width: =400
            X: =lblMaterialOverall.X + lblMaterialOverall.Width
            Y: =lblMaterialOverall.Y
            ZIndex: =13

        lblMaterialOverall As label:
            Height: =20
            Text: =gblPF_UI_MaterialValueOverall
            Width: =65
            X: =10
            Y: =690
            ZIndex: =14

        conHeader As groupContainer.manualLayoutContainer:
            Height: =120
            Width: =Parent.Width
            ZIndex: =15

            lblHeaderGameTitle As label:
                Align: =Align.Center
                Color: =RGBA(221, 79, 14, 1)
                Font: =Font.'Dancing Script'
                Height: =55
                Size: =34
                Text: ="Perty Fish"
                Width: =Parent.Width
                ZIndex: =1

            lblHeaderMode As label:
                Fill: =gblPF_UI_ModeFill
                Height: =25
                Text: =gblPF_UI_ModeText
                Width: =Parent.Width/2
                Y: =lblHeaderGameTitle.Height
                ZIndex: =2

            lblHeaderThinking As label:
                Fill: =gblPF_UI_ThinkingFill
                Height: =lblHeaderMode.Height
                Text: =gblPF_UI_ThinkingText
                Width: =lblHeaderMode.Width
                X: =lblHeaderMode.Width
                Y: =lblHeaderMode.Y
                ZIndex: =3

            lblHeaderThinkingProgress As label:
                Fill: =LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData.thinkingProgressFill
                Height: =lblHeaderThinking.Height
                Text: =LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData.thinkingProgressText
                Visible: =LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData.thinkingProgressVisible
                Width: =LookUp(colPF_DYNAMIC_DATA, dataName=DYNAMIC_DATA_PF_NAME).uiData.thinkingProgressWidth
                X: =lblHeaderThinking.X
                Y: =lblHeaderThinking.Y
                ZIndex: =4

            lblHeaderStatus As label:
                Fill: =gblPF_UI_StatusFill
                FontWeight: =FontWeight.Bold
                Height: =lblHeaderMode.Height
                Text: =gblPF_UI_StatusText
                Width: =lblHeaderMode.Width
                X: =lblHeaderMode.X
                Y: =lblHeaderMode.Y + lblHeaderMode.Height
                ZIndex: =5

            lblHeaderDiagnosticMsg As label:
                Fill: =gblPF_UI_DiagnosticFill
                Height: =lblHeaderMode.Height
                Text: =gblPF_UI_DiagnosticText
                Width: =lblHeaderMode.Width
                X: =lblHeaderStatus.X + lblHeaderStatus.Width
                Y: =lblHeaderStatus.Y
                ZIndex: =6

